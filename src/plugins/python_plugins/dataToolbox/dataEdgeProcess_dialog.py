# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dataEdgeHandleDialog
                                 A QGIS plugin
 dataEdgeHandle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-22
        git sha              : $Format:%H$
        copyright            : (C) 2024 by xing qiu company
        email                :  
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import glob
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from PyQt5.QtCore import QThread, pyqtSignal, QVariant, QSettings
from qgis.core import QgsVectorLayer, QgsWkbTypes, QgsGeometry, QgsMessageLog, Qgis
from os.path import split, splitext
from qgis.core import QgsVectorLayer
import shutil

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dataEdgeProcess_dialog_base.ui'))


class dataEdgeProcessDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, showDlg=True):
        """Constructor."""
        super(dataEdgeProcessDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.showDlg = showDlg
        #浏览数据目录
        self.data_button.clicked.connect(self.on_data_dir_clicked)
        #浏览接边检测结果目录
        self.check_button.clicked.connect(self.on_data_check_clicked)
        #浏览处理结果目录
        self.op_button.clicked.connect(self.on_data_op_clicked)
        
        #开始接边处理
        self.process_button.clicked.connect(self.on_edge_process_button_clicked)

        #关闭对话框
        self.process_close.clicked.connect(self.on_close_button_clicked)

        self.settings = QSettings('XingqiuCompany', 'dataEdgeProcess')
        self.data_dir_edit.setText(self.settings.value('data_path', ''))
        self.data_check_edit.setText(self.settings.value('check_path', ''))
        self.data_op_edit.setText(self.settings.value('op_path', ''))

    def on_data_dir_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择数据目录", "")
        self.data_dir_edit.setText(str(folder_path))
        self.settings.setValue('data_path', str(folder_path))

    def on_data_check_clicked(self):
        folder_path1 = QFileDialog.getExistingDirectory(None, "选择接边检测结果目录", "")
        self.data_check_edit.setText(str(folder_path1))
        self.settings.setValue('check_path', str(folder_path1))

    def on_data_op_clicked(self):
        folder_path2 = QFileDialog.getExistingDirectory(None, "选择处理结果目录", "")
        self.data_op_edit.setText(str(folder_path2))
        self.settings.setValue('op_path', str(folder_path2))

    def on_edge_process_button_clicked(self):
        if len(self.data_dir_edit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        
        if len(self.data_check_edit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '接边检测结果目录不能为空')
            return
        
        if len(self.data_op_edit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '处理结果目录不能为空')
            return
        

        self.progressBar.setValue(0)
        if self.showDlg:
            QApplication.processEvents()
        
        self.processCls = processData()
        self.processCls.setParam(self.data_dir_edit.text(), self.data_check_edit.text(), self.data_op_edit.text(), self.progressBar, self.showDlg)
        #self.thread.progress_signal.connect(self.progressBar.setValue)
        self.processCls.process()
        # folder_path = QFileDialog.getExistingDirectory(None, "选择数据目录", "")
        # self.dataLineEdit.setText(str(folder_path))
        # self.settings.setValue('data_path', str(folder_path))

    def process(self, inputPath, checkPath, outPath):
        self.processCls = processData()
        self.processCls.setParam(inputPath, checkPath, outPath, self.progressBar, self.showDlg)
        #self.thread.progress_signal.connect(self.progressBar.setValue)
        self.processCls.process()

    def on_close_button_clicked(self):
        self.close()

    def reset_progress_bar(self):
        self.progressBar.setValue(0)

class processData():
    # 创建一个信号，当有更新时发送
    #progress_signal = pyqtSignal(int)
    def setParam(self, data_dir_path, check_dir_path, op_dir_path, progressBar, showDlg):
        self.data_dir_path = data_dir_path
        self.check_dir_path = check_dir_path
        self.op_dir_path = op_dir_path
        self.progressBar = progressBar
        self.max_thread_num = 100
        self.result_dir_name = "result"
        self.showDlg = showDlg

    def process(self):
        #QgsMessageLog.logMessage('hhh', 'aaa', level=Qgis.MessageLevel.Info)
        self.progressBar.setValue(1)
        if self.showDlg:
            QApplication.processEvents()
        else:
            print('开始接边')
        check_data_paths = []
        vector_aj_files = glob.glob(os.path.join(self.check_dir_path, "AJ_*.shp"))
        for aj_shp_file_path in vector_aj_files:
            check_data_paths.append(aj_shp_file_path)

        vector_bj_files = glob.glob(os.path.join(self.check_dir_path, "BJ_*.shp"))
        for bj_shp_file_path in vector_bj_files:
            check_data_paths.append(bj_shp_file_path)

            
        new_data_dir_path = os.path.join(self.op_dir_path, self.result_dir_name)
        if os.path.exists(new_data_dir_path):
            shutil.rmtree(new_data_dir_path)  # 删除目标文件夹
        shutil.copytree(self.data_dir_path, new_data_dir_path)
        self.progressBar.setValue(10)
        if self.showDlg:
            QApplication.processEvents()
        else:
            print('接边进度:10%')
        if len(check_data_paths) == 0:
            if self.showDlg:
                self.progressBar.setValue(100)
                QApplication.processEvents()
                QMessageBox.information(None, '提示', '完成') 
            else:
                print("接边完成!")  
            return

        cur_step = 85.0 / len(check_data_paths)
        cur_future_prog = 0
        #因为更新涉及到qgsvectorlayer的多线程安全，特别是gpkg文件就不用多线程进行处理了

        result_data = ""
        check_field_name = "remarks"
        current_x_name = "current_x"
        current_y_name = "current_y"
        describe_field_name = 'describe'
        remarks_values_count = 12
        for check_data_path in check_data_paths:
            operator_data_dict = {}
            file_base_name = splitext(split(check_data_path)[1])[0]
            file_base_names = file_base_name.split("_")
            if len(file_base_names) < 2:
                cur_future_prog = cur_future_prog + 1
                self.progressBar.setValue((int)(cur_step * cur_future_prog + 1))
                if self.showDlg:
                    QApplication.processEvents()
                continue

            check_vector_layer = QgsVectorLayer(check_data_path)
            describe_field_index = check_vector_layer.fields().indexOf(describe_field_name)
            is_find_field = False
            for field in check_vector_layer.fields():
                if field.name() != check_field_name:
                    continue
                is_find_field = True
                break

            if is_find_field == False:
                cur_future_prog = cur_future_prog + 1
                self.progressBar.setValue((int)(cur_step * cur_future_prog + 1))
                if self.showDlg:
                    QApplication.processEvents()
                continue

            data_feature_iterator = check_vector_layer.getFeatures()    
            if file_base_names[0] != 'AJ' and file_base_names[0] != 'BJ':
                cur_future_prog = cur_future_prog + 1
                self.progressBar.setValue((int)(cur_step * cur_future_prog + 1))
                if self.showDlg:
                    QApplication.processEvents()
                continue

            for data_feature in data_feature_iterator:
                current_x = float(data_feature.attribute(current_x_name))
                current_y = float(data_feature.attribute(current_y_name))
                remarks_values = data_feature.attribute(check_field_name).split(',')
                if len(remarks_values) != remarks_values_count:
                    continue

                #dataType
                dataType = int(remarks_values[remarks_values_count - 1])
                mergeType = int(remarks_values[remarks_values_count - 2])
                vector_paths = []
                vector_layers = []
                if dataType == 0:
                    # vector_paths = [os.path.join(new_data_dir_path, remarks_values[0] + ".shp"), os.path.join(new_data_dir_path, remarks_values[5] + ".shp")]
                    # if file_base_names[0] == 'BJ':
                    vector_paths = [os.path.join(new_data_dir_path, remarks_values[0], remarks_values[1]+ ".shp"), os.path.join(new_data_dir_path, remarks_values[5],  remarks_values[6]+ ".shp")]
                    #3为顺势法表示不处理
                    if mergeType == 3:
                        if vector_paths[0] not in operator_data_dict:
                            operator_data_dict[vector_paths[0]] = False

                        if vector_paths[1] not in operator_data_dict:
                            operator_data_dict[vector_paths[1]] = False  
                        continue
                    else:
                        vector_layers = [QgsVectorLayer(vector_paths[0]), QgsVectorLayer(vector_paths[1])]
                else:
                    vector_paths = [os.path.join(new_data_dir_path, remarks_values[0] + ".gpkg"), os.path.join(new_data_dir_path, remarks_values[5] + ".gpkg")]
                    #3为顺势法表示不处理
                    if mergeType == 3:
                        if vector_paths[0] not in operator_data_dict:
                            operator_data_dict[vector_paths[0]] = False

                        if vector_paths[1] not in operator_data_dict:
                            operator_data_dict[vector_paths[1]] = False
                        continue
                    else:
                        vector_layers = [QgsVectorLayer(vector_paths[0] + '|layername=' + remarks_values[1], remarks_values[1], 'ogr'), \
                                            QgsVectorLayer(vector_paths[1]+ '|layername=' + remarks_values[6], remarks_values[6], 'ogr')]
                for i in range(len(vector_layers)):
                    vector_feature = vector_layers[i].getFeature(int(remarks_values[i * 5 + 2]))
                    if vector_feature.isValid() == False:
                        if vector_paths[i] not in operator_data_dict:
                            operator_data_dict[vector_paths[i]] = False
                        continue
                    
                    vector_feature_geo = vector_feature.geometry()
                    if vector_feature_geo.isGeosValid() == False:
                        if vector_paths[i] not in operator_data_dict:
                            operator_data_dict[vector_paths[i]] = False
                        continue
                    
                    if vector_layers[i].wkbType() == QgsWkbTypes.MultiPointZ or vector_layers[i].wkbType() == QgsWkbTypes.MultiPoint or vector_layers[i].wkbType() == QgsWkbTypes.MultiPointZM:
                        muti_geo_pts = vector_feature_geo.asMultiPoint()

                        pts_part = int(remarks_values[i * 5 + 3])
                        if len(muti_geo_pts) < pts_part:
                            if vector_paths[i] not in operator_data_dict:
                                operator_data_dict[vector_paths[i]] = False
                            continue

                        vector_layers[i].startEditing()
                        muti_geo_pts[pts_part].setX(current_x)
                        muti_geo_pts[pts_part].setY(current_y)
                        vector_feature.setGeometry(QgsGeometry.fromMultiPointXY(muti_geo_pts))
                        vector_layers[i].updateFeature(vector_feature)
                        vector_layers[i].commitChanges()
                        operator_data_dict[vector_paths[i]] = True

                        check_vector_layer.startEditing()
                        check_vector_layer.changeAttributeValue(data_feature.id(), describe_field_index, '已处理')
                        check_vector_layer.commitChanges()

                    elif vector_layers[i].wkbType() == QgsWkbTypes.MultiLineStringZ or vector_layers[i].wkbType() == QgsWkbTypes.MultiLineString or vector_layers[i].wkbType() == QgsWkbTypes.MultiLineStringZM:
                        muti_geo_lines = vector_feature_geo.asMultiPolyline()

                        pts_part = int(remarks_values[i * 5 + 3])
                        pt_last =  int(remarks_values[i * 5 + 4])
                        if len(muti_geo_lines) < pts_part:
                            if vector_paths[i] not in operator_data_dict:
                                operator_data_dict[vector_paths[i]] = False
                            continue

                        vector_layers[i].startEditing()
                        if pt_last:
                            muti_geo_lines[pts_part][len(muti_geo_lines[pts_part])-1].setX(current_x)
                            muti_geo_lines[pts_part][len(muti_geo_lines[pts_part])-1].setY(current_y)
                        else:
                            muti_geo_lines[pts_part][0].setX(current_x)
                            muti_geo_lines[pts_part][0].setY(current_y)
                        vector_feature.setGeometry(QgsGeometry.fromMultiPolylineXY(muti_geo_lines))
                        vector_layers[i].updateFeature(vector_feature)
                        vector_layers[i].commitChanges()
                        operator_data_dict[vector_paths[i]] = True

                        check_vector_layer.startEditing()
                        check_vector_layer.changeAttributeValue(data_feature.id(), describe_field_index, '已处理')
                        check_vector_layer.commitChanges()
                    elif vector_layers[i].wkbType() == QgsWkbTypes.MultiPolygonZ or vector_layers[i].wkbType() == QgsWkbTypes.MultiPolygon or vector_layers[i].wkbType() == QgsWkbTypes.MultiPolygonZM:
                            #面状暂时不处理
                        if vector_paths[i] not in operator_data_dict:
                            operator_data_dict[vector_paths[i]] = False
                    elif vector_layers[i].wkbType() == QgsWkbTypes.Point or vector_layers[i].wkbType() == QgsWkbTypes.PointZ or vector_layers[i].wkbType() == QgsWkbTypes.PointZM:
                        geo_pt = vector_feature_geo.asPoint()
                        vector_layers[i].startEditing()
                        geo_pt.setX(current_x)
                        geo_pt.setY(current_y)
                        vector_feature.setGeometry(QgsGeometry.fromPointXY(geo_pt))
                        vector_layers[i].updateFeature(vector_feature)
                        vector_layers[i].commitChanges()
                        operator_data_dict[vector_paths[i]] = True

                        check_vector_layer.startEditing()
                        check_vector_layer.changeAttributeValue(data_feature.id(), describe_field_index, '已处理')
                        check_vector_layer.commitChanges()                                                
                    elif vector_layers[i].wkbType() == QgsWkbTypes.LineString or vector_layers[i].wkbType() == QgsWkbTypes.LineStringZ or vector_layers[i].wkbType() == QgsWkbTypes.LineStringZM:
                        geo_line = vector_feature_geo.asPolyline()
                        vector_layers[i].startEditing()
                        if pt_last:
                            geo_line[len(geo_line)-1].setX(current_x)
                            geo_line[len(geo_line)-1].setY(current_y)
                        else:
                            geo_line[0].setX(current_x)
                            geo_line[0].setY(current_y)
                        vector_feature.setGeometry(QgsGeometry.fromMultiPolylineXY(muti_geo_lines))
                        vector_layers[i].updateFeature(vector_feature)
                        vector_layers[i].commitChanges()
                        operator_data_dict[vector_paths[i]] = True

                        check_vector_layer.startEditing()
                        check_vector_layer.changeAttributeValue(data_feature.id(), describe_field_index, '已处理')
                        check_vector_layer.commitChanges()
                    elif vector_layers[i].wkbType() == QgsWkbTypes.Polygon or vector_layers[i].wkbType() == QgsWkbTypes.PolygonZ or vector_layers[i].wkbType() == QgsWkbTypes.PolygonZM:
                        if vector_paths[i] not in operator_data_dict:
                            operator_data_dict[vector_paths[i]] = False
                    else:
                        if vector_paths[i] not in operator_data_dict:
                            operator_data_dict[vector_paths[i]] = False

            result_data =  result_data + "process:" + check_data_path + "\n"
            for dict_key in operator_data_dict:
                if operator_data_dict[dict_key]:
                    result_data = result_data + "已接边:" + dict_key + "\n"
                else:
                    result_data = result_data + "没有要接边的数据:" + dict_key + "\n"
            result_data = result_data + "\n\n"
            cur_future_prog = cur_future_prog + 1
            self.progressBar.setValue((int)(cur_step * cur_future_prog + 10))
            if self.showDlg:
                QApplication.processEvents()     
            else:
                print('接边进度:'+ str((int)(cur_step * cur_future_prog + 1)) + '%')       
        result_data = result_data + "finish!"
        save_log_path = os.path.join(self.op_dir_path, "link_data.log")
        with open(save_log_path, "w") as f:
            f.write(result_data)
            f.flush()
            f.close()
            if self.showDlg:
                self.progressBar.setValue(100)
                QApplication.processEvents()
                QMessageBox.information(None, '提示', '完成') 
            else:
                print("接边完成!")   
