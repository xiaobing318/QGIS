# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dataEdgeCheckDialog
                                 A QGIS plugin
 dataEdgeCheck
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by 星球
        email                : 星球
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import glob
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from qgis.core import QgsVectorLayer, QgsWkbTypes, QgsFeature, QgsFields, QgsField, QgsUnitTypes, QgsDistanceArea, QgsProject, QgsGeometry, QgsVectorLayerExporter, QgsMessageLog,QgsPointXY, QgsPoint,Qgis,QgsFeatureRequest,QgsCoordinateReferenceSystem
from osgeo import osr
from os.path import split, splitext
from PyQt5.QtCore import QThread, pyqtSignal, QVariant, QSettings
import math
import concurrent.futures
from PyQt5.QtGui import QIntValidator
import threading
import sys
from osgeo import ogr

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dataEdgeDetection_dialog_base.ui'))

class dataEdgeDetectionDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, showDlg=True):
        """Constructor."""
        super(dataEdgeDetectionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.showDlg = showDlg
        #单位m
        self.no_do_distance = 0.0001
        self.force_method_distance = 0.0003
        self.average_method_distance = 0.0006
        self.optimize_method_distance = 0.001
        self.homeopathy_method_distance = 0.002
        self.scale_num.setValidator(QIntValidator())
        #浏览被进行数据检测的数据
        self.dataPushButton.clicked.connect(self.on_data_button_clicked)
        #浏览附属数据检测的数据
        self.affiliationPushButton.clicked.connect(self.on_affiliation_button_clicked)
        #匹配配置文件导入
        self.matchPushButton.clicked.connect(self.on_match_button_clicked)
        #接边结果导入
        self.resultPushButton.clicked.connect(self.on_result_button_clicked)
        
        #开始接边
        self.detectionPushButton.clicked.connect(self.on_detection_button_clicked)

        #关闭对话框
        self.closePushButton.clicked.connect(self.on_close_button_clicked)
        self.settings = QSettings('XingqiuCompany', 'dataEdgeDetection')

        self.dataLineEdit.setText(self.settings.value('data_path', ''))
        self.scale_num.setText(self.settings.value('scale_num', '10000'))
        self.affiliationLineEdit.setText(self.settings.value('affiliation_path', ''))
        affiliation_layer = QgsVectorLayer(self.affiliationLineEdit.text())
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

        self.matchLineEdit.setText(self.settings.value('config_path', ''))               
        self.resultLineEdit.setText(self.settings.value('result_path', ''))

        dataType = self.settings.value('data_type', 0, type=int)
        featureType = self.settings.value('feature_type', 0, type=int)
        matchType = self.settings.value('match_type', 0, type=int)
        if dataType == 0:
            self.shpRadioButton.setChecked(True)
        else:
            self.gpkgRadioButton.setChecked(True)

        if featureType == 0:
            self.pointRadioButton.setChecked(True)
        elif featureType == 1:
            self.lineRadioButton.setChecked(True)
        else:
            self.polygonRadioButton.setChecked(True)

        if matchType == 0:
            self.mapRadioButton.setChecked(True)
        else:
            self.edgeRadioButton.setChecked(True)

    def reset_progress_bar(self):
        self.progressBar.setValue(0)

    def on_data_button_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择数据目录", "")
        self.dataLineEdit.setText(str(folder_path))
        self.settings.setValue('data_path', str(folder_path))
    
    def on_affiliation_button_clicked(self):
        affiliation_filename_path, ok = QFileDialog.getOpenFileName(self,
                                "导入图框数据",
                               "",
                                "shape Files (*.shp)")
        if ok:
            self.affiliationLineEdit.setText(str(affiliation_filename_path))
            self.settings.setValue('affiliation_path', str(affiliation_filename_path))
        else:
            self.affiliationLineEdit.setText('')
            self.settings.setValue('affiliation_path', '')            

        affiliation_layer = QgsVectorLayer(affiliation_filename_path)
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

    def on_match_button_clicked(self):
        match_filename_path, ok = QFileDialog.getOpenFileName(self,
                                "选择配置文件",
                               "",
                                "txt Files (*.txt)")
        if ok:
            self.matchLineEdit.setText(str(match_filename_path))
            self.settings.setValue('config_path', str(match_filename_path))
        else:
            self.matchLineEdit.setText('')
            self.settings.setValue('config_path', '')  

    def on_result_button_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择接边结果目录", "")
        self.resultLineEdit.setText(str(folder_path))
        self.settings.setValue('result_path', str(folder_path))
    
    def process(self, nameField, num_scale, dataType, featureType, inputPath, matchType, affPath, configPath, outPath):    
        self.thread = WorkerThread()
        no_do_distance = self.no_do_distance * num_scale
        force_method_distance = self.force_method_distance * num_scale
        average_method_distance = self.average_method_distance * num_scale
        optimize_method_distance = self.optimize_method_distance * num_scale
        homeopathy_method_distance = self.homeopathy_method_distance * num_scale 
        self.thread.setParam(nameField, dataType, featureType, inputPath, matchType, affPath, configPath, outPath, no_do_distance, force_method_distance,
        average_method_distance, optimize_method_distance, homeopathy_method_distance, num_scale)
        self.thread.progress_signal.connect(self.connect_fun)
        self.thread.run()

    def on_detection_button_clicked(self):
        self.settings.setValue('scale_num', self.scale_num.text())
        num_scale = 0
        try:
            num_scale = int(self.scale_num.text())
        except ValueError:
            QMessageBox.warning(self, '警告', '比例尺输入不合法')
            return
        
        if num_scale <= 0:
            QMessageBox.warning(self, '警告', '比例尺输入必须为大于0的整数')
            return            
        
        dataType = 0 if self.shpRadioButton.isChecked() else 1
        featureType = 0 if self.pointRadioButton.isChecked() else 1 if self.lineRadioButton.isChecked() else 2
        matchType = 0 if self.mapRadioButton.isChecked() else 1

        self.settings.setValue('data_type', dataType)
        self.settings.setValue('feature_type', featureType)
        self.settings.setValue('match_type', matchType)

        if len(self.dataLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        
        if len(self.affiliationLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '附属数据路径不能为空')
            return
        
        if len(self.matchLineEdit.text()) == 0:
            if self.showDlg:            
                QMessageBox.warning(self, '警告', '配置文件路径不能为空')
            return
        
        if len(self.resultLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '接边结果目录不能为空')
            return

        self.progressBar.setValue(0)
        if self.showDlg:
            QApplication.processEvents()

        self.thread = WorkerThread()

        nameField = self.comboBox.currentText()
        no_do_distance = self.no_do_distance * num_scale
        force_method_distance = self.force_method_distance * num_scale
        average_method_distance = self.average_method_distance * num_scale
        optimize_method_distance = self.optimize_method_distance * num_scale
        homeopathy_method_distance = self.homeopathy_method_distance * num_scale 
        self.thread.setParam(nameField, dataType, featureType, self.dataLineEdit.text(), matchType, self.affiliationLineEdit.text(), self.matchLineEdit.text(), self.resultLineEdit.text(), no_do_distance, force_method_distance,
        average_method_distance, optimize_method_distance, homeopathy_method_distance, num_scale)
        self.thread.progress_signal.connect(self.connect_fun)
        self.thread.start()
        #dataEdgeCheck(dataType, featureType, self.dataLineEdit.text(), matchType, self.affiliationLineEdit.text(), self.matchLineEdit.text(), self.resultLineEdit.text(), self.progressBar, self)

    def connect_fun(self, prog, msg_data):
        if self.showDlg:
            self.progressBar.setValue(prog)
        else:
            print("当前进度:" + str(prog) + "%")

        if prog >= 100:
            if self.showDlg:
                if len(msg_data) > 0:
                    QMessageBox.information(None, '提示', msg_data)
            else:
                print("运行完成！")

    def on_close_button_clicked(self):
        self.close()

class WorkerThread(QThread):
    # 创建一个信号，当有更新时发送
    progress_signal = pyqtSignal(int, str)
    
    def setParam(self, nameField, dataType, featureType, inputDir, matchType, affiliationFilePath, configFilePath, resultDir, no_do_distance, force_method_distance,
        average_method_distance, optimize_method_distance, homeopathy_method_distance, scale):
        self.nameField = nameField
        self.dataType = dataType
        self.featureType = featureType
        self.inputDir = inputDir
        self.matchType = matchType    
        self.affiliationFilePath = affiliationFilePath
        self.configFilePath = configFilePath   
        self.resultDir = resultDir
        self.no_do_distance = no_do_distance
        self.force_method_distance = force_method_distance
        self.average_method_distance = average_method_distance
        self.optimize_method_distance = optimize_method_distance
        self.homeopathy_method_distance = homeopathy_method_distance
        self.max_thread_num = 100
        self.scale = scale

    def run(self):
        if self.matchType == 1:
            if self.featureType == 0:
                self.point_Arbitrary_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)
            elif self.featureType == 1:
                self.line_Arbitrary_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)
            else:
                self.polygon_Arbitrary_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)
        else:
            if self.featureType == 0:
                self.point_Border_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)
            elif self.featureType == 1:
                self.line_Border_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)
            else:
                self.polygon_Border_Edge_Check(self.inputDir, self.affiliationFilePath, self.configFilePath, self.resultDir, self.dataType)



    def get_Gpkg_Layers(self, gpkg_path):
        layer_list = []
        driver = ogr.GetDriverByName('GPKG')
        gpkg_source = driver.Open(gpkg_path, 0)  # 0 表示只读模式
        if gpkg_source is None:
            return layer_list
        
        # 获取所有图层名称
        layers = gpkg_source.GetLayerCount()  # 获取图层数量
        layer_names = [gpkg_source.GetLayerByIndex(i).GetName() for i in range(layers)]
        for name in layer_names:
            uri = f'{gpkg_path}|layername={name}'
            layer = QgsVectorLayer(uri, name, 'ogr')
            if layer.isValid() and (layer.geometryType() == QgsWkbTypes.PointGeometry or layer.geometryType() == QgsWkbTypes.LineGeometry or layer.geometryType() == QgsWkbTypes.PolygonGeometry):
                layer_list.append(layer)
        return layer_list

    def split_data_by_feature(self, affiliation_id_match_layers, affiliation_id, affiliation_layer, isAffiliationMuti, isPt):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        data_layers = affiliation_id_match_layers[affiliation_id][0]
        aff_feature = affiliation_layer.getFeature(affiliation_id)
        aff_feature_geometry = aff_feature.geometry()

        data_len = 0
        if isAffiliationMuti:
            feature_geo = aff_feature_geometry.asMultiPolygon()
            for i in range(len(feature_geo)):
                for j in range(len(feature_geo[i])):
                    data_len = data_len + len(feature_geo[i][j])
        else:
            data_len = len(feature_geo)

        affi_buffer_geometry = aff_feature_geometry.buffer(-factor * self.homeopathy_method_distance, data_len)
        affi_diff_geometry = aff_feature_geometry.difference(affi_buffer_geometry)

        intersect_ids = []
        for data_layer in data_layers:
            data_feature_iterator = data_layer.getFeatures()
            for data_feature in data_feature_iterator:
                data_geometry = data_feature.geometry()
                if isPt:
                    if affi_diff_geometry.contains(data_geometry) == False:
                        continue
                else:
                    if data_geometry.intersects(affi_diff_geometry) == False:
                        continue
                intersect_ids.append([data_layer, data_feature.id(), data_layers[data_layer]])        
        return affiliation_id, intersect_ids

    def compute_point_intersects(self, featureid1, featureid2, config_dict, affiliation_layer, dictFeatureIds, distanceCalculator, isAffiliationMuti, dataType):
        affi_geo1 = affiliation_layer[featureid1][1]

        match_results = []
        feature1_ids = dictFeatureIds[featureid1]
        feature2_ids = dictFeatureIds[featureid2]

        for data_layer1, feature1_id, file_name1 in feature1_ids:
            layer_name1 = data_layer1.name()
            if dataType == 0:
                layer_name1 = splitext(split(data_layer1.source())[1])[0]
            layer_ismuti1 = data_layer1.wkbType() == QgsWkbTypes.MultiPoint or data_layer1.wkbType() == QgsWkbTypes.MultiPointZ or data_layer1.wkbType() == QgsWkbTypes.MultiPointZM
            feature1 = data_layer1.getFeature(feature1_id)
            feature_geometry1 = feature1.geometry()
            if layer_ismuti1:
                tmp_muti_poly = feature_geometry1.asMultiPoint()
                feature_geometry1 = QgsGeometry.fromPointXY(tmp_muti_poly[0])
            feature1_pt = feature_geometry1.asPoint()
            for data_layer2, feature2_id, file_name2 in feature2_ids:
                layer_name2 = data_layer2.name()
                if dataType == 0:
                    layer_name2 = splitext(split(data_layer2.source())[1])[0]
                layer_ismuti2 = data_layer2.wkbType() == QgsWkbTypes.MultiPoint or data_layer2.wkbType() == QgsWkbTypes.MultiPointZ or data_layer2.wkbType() == QgsWkbTypes.MultiPointZM
                feature2 = data_layer2.getFeature(feature2_id)

                if (layer_name1 in config_dict and layer_name2 not in config_dict) \
                or (layer_name1 not in config_dict and layer_name2  in config_dict) \
                or (layer_name1 in config_dict and layer_name2 in config_dict and len(config_dict[layer_name1]) != len(config_dict[layer_name2])):
                    continue

                if layer_name1 in config_dict and layer_name2 in config_dict:
                    attribs1 = config_dict[layer_name1]
                    attribs2 = config_dict[layer_name2]

                    isEqual = True
                    for i in range(len(attribs1)):
                        if feature1.attribute(attribs1[i]) == feature2.attribute(attribs2[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线    
                feature_geometry2 = feature2.geometry()
                if layer_ismuti2:
                    tmp_muti_poly = feature_geometry2.asMultiPoint()
                    feature_geometry2 = QgsGeometry.fromPointXY(tmp_muti_poly[0])

                feature2_pt = feature_geometry2.asPoint()
                pt_distance = distanceCalculator.measureLine(feature1_pt, feature2_pt) 
                #QgsMessageLog.logMessage(affiliation_layer[featureid1][0].source() + ',' + str(feature1.id()) + ',' + affiliation_layer[featureid2][0].source() + ',' + str(feature2.id()) + ',' + str(distances[min_value_index]), 'aaa', level=Qgis.MessageLevel.Info)
                #计算结果点
                mergeType = -1
                #强制法，平均法、优化法计算交点
                if pt_distance < self.no_do_distance:
                    mergeType = 4
                elif pt_distance < self.force_method_distance:
                    mergeType = 0
                elif pt_distance < self.average_method_distance:
                    mergeType = 1
                elif pt_distance < self.optimize_method_distance:
                    mergeType = 2
                elif pt_distance < self.homeopathy_method_distance:
                    mergeType = 3
                if mergeType == -1 or mergeType == 4:
                    continue

                feature = QgsFeature()
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), 0, 1, file_name2, layer_name2, feature2.id(), 0, 1, mergeType, dataType, pt_distance, self.scale)

                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(feature1_pt.x(), feature1_pt.y()), QgsPoint(feature2_pt.x(), feature2_pt.y())])
                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pt.x()/2+feature2_pt.x()/2,feature1_pt.y()/2 + feature2_pt.y()/2))

                feature_xy = feature.geometry().asPoint()
                feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
                match_results.append(feature)
                break
        return match_results

    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    def point_Arbitrary_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")
        vector_files = []
        if dataType == 0:
            for root, dirs, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".shp") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    file_datas = file_path.split(os.path.sep)
                    vector_files.append([file_datas[len(file_datas)-2], file_path])
        else:
            for root, _, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".gpkg") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    tf_name = splitext(split(file_path)[1])[0]
                    vector_files.append([tf_name, file_path])

        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]

        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(affiliation_layer.crs(), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")

        file_match_layers = {}
        for tf_name, vector_file in vector_files:
            if dataType == 0:
                file_name = splitext(split(vector_file)[1])[0]
                vector_layer = QgsVectorLayer(vector_file)
                if vector_layer.isValid() == False:
                    continue
                if vector_layer.geometryType() != QgsWkbTypes.PointGeometry:
                    continue
                file_match_layers[vector_layer] = [tf_name, file_name]
            else:
                vector_layers = self.get_Gpkg_Layers(vector_file)
                for layer in vector_layers:
                    if layer.geometryType() != QgsWkbTypes.PointGeometry:    
                        continue
                    #图幅名 文件名
                    file_match_layers[layer] = [tf_name, tf_name]

        iterator = affiliation_layer.getFeatures()
        affiliation_id_match_layers = {}
        #通过feature与layer名字对应过滤一部分layer
        for feature in iterator:
            feature_geo = feature.geometry()
            feature_name_value = feature.attribute(self.nameField)
            match_layers = {}
            for tmp_match_layer in file_match_layers:   
                tf_name = file_match_layers[tmp_match_layer][0]
                file_name = file_match_layers[tmp_match_layer][1]
                if feature_name_value != tf_name:
                    continue
                match_layers[tmp_match_layer] = file_name
            if len(match_layers) > 0:
                affiliation_id_match_layers[feature.id()] = [match_layers, feature_geo, feature_name_value]

        #通过过滤之后的affiliation_id_match_layers获取layer计算layer与layer之间是否会有关系:
        match_layer_keys = []
        match_layer_values = []
        affiliation_feature_ids = []
        iterator = affiliation_layer.getFeatures()
        for feature in iterator:
            if feature.id() not in affiliation_id_match_layers:
                continue

            #affiliation_feature_ids.append(feature.id())    
            feature_geo = feature.geometry()
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for tmp_affiliation_id in affiliation_id_match_layers:
                if feature.id() == tmp_affiliation_id:
                    continue

                if buffer_geometry.intersects(affiliation_id_match_layers[tmp_affiliation_id][1]) == False:
                    continue
                
                if tmp_affiliation_id in match_layer_keys:
                    continue

                match_layer_keys.append(feature.id())
                match_layer_values.append(tmp_affiliation_id)
                
        layer_data_keys = match_layer_keys + match_layer_values
        for layer_data_key in layer_data_keys:
            if layer_data_key in affiliation_feature_ids:
                continue
            affiliation_feature_ids.append(layer_data_key)

        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "根据附属文件没有匹配到任何图层")
            return True, ""
        
        dictFeatureIds = {}
        cur_step = 70.0 / len(affiliation_feature_ids)
        cur_future_prog = 0
        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = { executor.submit(self.split_data_by_feature, affiliation_id_match_layers, affiliation_feature_ids[n], affiliation_layer, isAffiliationMuti, True): n for n in range(len(affiliation_feature_ids)) }
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                aff_feature_id, feature_ids = future_data.result()
                dictFeatureIds[aff_feature_id] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            #QgsMessageLog.logMessage(str(len(match_layer_values)), 'aaa', level=Qgis.MessageLevel.Info)
            result_add_features = []
            step = 20.0 / len(match_layer_keys)
            curprog = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_point_intersects, match_layer_keys[i], match_layer_values[i], config_dict, affiliation_id_match_layers, dictFeatureIds, distanceCalculator, isAffiliationMuti, dataType): i for i in range(len(match_layer_keys)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    result_add_features = result_add_features + future.result()
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 71), "")

                result_layer_name = 'AJ_point'
                source_layer_name = 'Point?' + result_layer_name
                result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                result_layer.setCrs(affiliation_layer.crs())
                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)
                result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                result_layer.updateFields()
                result_layer.startEditing()
                
                for i in range(len(result_add_features)):
                    result_layer.dataProvider().addFeature(result_add_features[i])
                result_layer.commitChanges()

                options = {}
                options['overwrite'] = True
                options['driverName'] = 'ESRI Shapefile'
                #options['driverName'] = 'GPKG'
                #options['layerName'] = 'my_out_table'
                QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")

    def compute_line_intersects(self, featureid1, featureid2, config_dict, affiliation_layer, dictFeatureIds, distanceCalculator, isAffiliationMuti, dataType):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        affi_geo1 = affiliation_layer[featureid1][1]
        affi_geo2 = affiliation_layer[featureid2][1]

        match_results = []
        match_result_tmps = []
        feature1_ids = dictFeatureIds[featureid1]
        feature2_ids = dictFeatureIds[featureid2]
        
        res_feature1_first_pt = None
        res_feature1_second_pt = None
        res_feature1_last_pt = None
        res_feature1_selast_pt = None

        res_feature2_first_pt = None
        res_feature2_second_pt = None
        res_feature2_last_pt = None
        res_feature2_selast_pt = None
        for data_layer1, feature1_id, file_name1 in feature1_ids:
            layer_name1 = data_layer1.name()
            if dataType == 0:
                layer_name1 = splitext(split(data_layer1.source())[1])[0]
            layer_ismuti1 = data_layer1.wkbType() == QgsWkbTypes.MultiLineString or data_layer1.wkbType() == QgsWkbTypes.MultiLineStringZ or data_layer1.wkbType() == QgsWkbTypes.MultiLineStringZM
            feature1 = data_layer1.getFeature(feature1_id)
            feature_min_dis = sys.float_info.max

            feature1_index = 0
            feature2_cur_id = 0
            feature2_index = 0
            mergeType = -1
            res_min_value_index = 0
            for data_layer2, feature2_id, file_name2 in feature2_ids:
                layer_name2 = data_layer2.name()
                if dataType == 0:
                    layer_name2 = splitext(split(data_layer2.source())[1])[0]
                layer_ismuti2 = data_layer2.wkbType() == QgsWkbTypes.MultiLineString or data_layer2.wkbType() == QgsWkbTypes.MultiLineStringZ or data_layer2.wkbType() == QgsWkbTypes.MultiLineStringZM
                feature2 = data_layer2.getFeature(feature2_id)

                if (layer_name1 in config_dict and layer_name2 not in config_dict) \
                or (layer_name1 not in config_dict and layer_name2  in config_dict) \
                or (layer_name1 in config_dict and layer_name2 in config_dict and len(config_dict[layer_name1]) != len(config_dict[layer_name2])):
                    continue

                if layer_name1 in config_dict and layer_name2 in config_dict:
                    attrib1s = config_dict[layer_name1]
                    attrib2s = config_dict[layer_name2]

                    isEqual = True
                    for i in range(len(attrib1s)):
                        if feature1.attribute(attrib1s[i]) == feature2.attribute(attrib2s[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线
                feature1_line_list = []
                feature_geometry1 = feature1.geometry()
                if layer_ismuti1:
                    tmp_muti_polys = feature_geometry1.asMultiPolyline()
                    for tmp_muti_poly in tmp_muti_polys:
                        feature1_line_list.append(tmp_muti_poly)
                else:
                    feature1_line_list.append(feature_geometry1.asPolyline())

                feature2_line_list = []
                feature_geometry2 = feature2.geometry()
                if layer_ismuti2:
                    tmp_muti_polys = feature_geometry2.asMultiPolyline()
                    for tmp_muti_poly in tmp_muti_polys:
                        feature2_line_list.append(tmp_muti_poly)
                else:
                    feature2_line_list.append(feature_geometry2.asPolyline())

                for i in range(len(feature1_line_list)):
                    for j in range(len(feature2_line_list)):
                        feature1_pt_list = feature1_line_list[i]
                        feature2_pt_list = feature2_line_list[j]

                        feature1_first_pt = feature1_pt_list[0]
                        #feature1_second_pt = feature1_pt_list[1]
                        feature1_last_pt = feature1_pt_list[len(feature1_pt_list) - 1]
                        #feature1_secast_pt = feature1_pt_list[len(feature1_pt_list) - 2]

                        feature2_first_pt = feature2_pt_list[0]
                        #feature2_second_pt = feature2_pt_list[1]
                        feature2_last_pt = feature2_pt_list[len(feature2_pt_list) - 1]
                        #feature2_selast_pt = feature2_pt_list[len(feature2_pt_list) - 2]

                        distance1 = distanceCalculator.measureLine([feature1_first_pt, feature2_first_pt])
                        distance2 = distanceCalculator.measureLine([feature1_last_pt, feature2_first_pt])
                        distance3 = distanceCalculator.measureLine([feature1_first_pt, feature2_last_pt])
                        distance4 = distanceCalculator.measureLine([feature1_last_pt, feature2_last_pt])
                        distances = [distance1, distance2, distance3, distance4]
                        min_value_index = min(range(len(distances)), key=distances.__getitem__)
                        
                        if distances[min_value_index] >= self.homeopathy_method_distance or distances[min_value_index] >= feature_min_dis:
                            continue

                        res_min_value_index = min_value_index
                        feature_min_dis = distances[min_value_index]
                        feature1_index = i
                        feature2_cur_id = feature2.id()
                        feature2_index = j
                        res_feature1_first_pt = feature1_pt_list[0]
                        res_feature1_second_pt = feature1_pt_list[1]
                        res_feature1_last_pt = feature1_pt_list[len(feature1_pt_list) - 1]
                        res_feature1_selast_pt = feature1_pt_list[len(feature1_pt_list) - 2]

                        res_feature2_first_pt = feature2_pt_list[0]
                        res_feature2_second_pt = feature2_pt_list[1]
                        res_feature2_last_pt = feature2_pt_list[len(feature2_pt_list) - 1]
                        res_feature2_selast_pt = feature2_pt_list[len(feature2_pt_list) - 2]

                        #强制法，平均法、优化法计算交点
                        if feature_min_dis < self.no_do_distance:
                            mergeType = 4
                        elif feature_min_dis < self.force_method_distance:
                            mergeType = 0
                        elif feature_min_dis < self.average_method_distance:
                            mergeType = 1
                        elif feature_min_dis < self.optimize_method_distance:
                            mergeType = 2
                        elif feature_min_dis < self.homeopathy_method_distance:
                            mergeType = 3
                        else:
                            continue

            if mergeType == -1:
                continue  

            feature = QgsFeature()
            matchResult = None
            feature1_pos_arr = [res_feature1_first_pt, res_feature1_second_pt, res_feature1_last_pt, res_feature1_selast_pt]
            feature2_pos_arr = [res_feature2_first_pt, res_feature2_second_pt, res_feature2_last_pt, res_feature2_selast_pt]

            feature1_data_pos = []
            feature2_data_pos = []
            if res_min_value_index == 0:
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), feature1_index, 0, \
                                                    file_name2, layer_name2, feature2_cur_id, feature2_index, 0, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [1, 0]
                feature2_data_pos = [1, 0]
            elif res_min_value_index == 1:
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), feature1_index, 1, \
                                                    file_name2, layer_name2, feature2_cur_id, feature2_index, 0, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [3, 2]
                feature2_data_pos = [1, 0]
            elif res_min_value_index == 2:
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), feature1_index, 0, \
                                                    file_name2, layer_name2, feature2_cur_id, feature2_index, 1, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [1, 0]
                feature2_data_pos = [3, 2]
            else:
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), feature1_index, 1, \
                                                    file_name2, layer_name2, feature2_cur_id, feature2_index, 1, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [3, 2]
                feature2_data_pos = [3, 2]

            if mergeType == 0:
                dx = feature1_pos_arr[feature1_data_pos[0]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature1_pos_arr[feature1_data_pos[0]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)

                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature1_pos_arr[feature1_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            elif mergeType == 1:
                #计算第一条线与面的交点
                intert_geo0 = QgsPoint()
                dx = feature1_pos_arr[feature1_data_pos[0]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature1_pos_arr[feature1_data_pos[0]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)
                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature1_pos_arr[feature1_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            #QgsMessageLog.logMessage(str(intert_geo.x()) + "," + str(intert_geo.y()), 'aaa', level=Qgis.MessageLevel.Info)
                            intert_geo0 = QgsPoint(intert_geo.x(),intert_geo.y())
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        intert_geo0 = QgsPoint(intert_geo.x(),intert_geo.y())
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    intert_geo0 = QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2)
                
                #计算第二条线与面的交点
                dx = feature2_pos_arr[feature2_data_pos[0]].x() - feature2_pos_arr[feature2_data_pos[1]].x()
                dy = feature2_pos_arr[feature2_data_pos[0]].y() - feature2_pos_arr[feature2_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)
                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature2_pos_arr[feature2_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature2_pos_arr[feature2_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo2.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue

                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x()/2 + intert_geo0.x()/2, intert_geo.y()/2 + intert_geo0.y()/2))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo2.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x()/2 + intert_geo0.x()/2, intert_geo.y()/2 + intert_geo0.y()/2))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            elif mergeType == 4:
                feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            else:
                #优化法
                dx = feature2_pos_arr[feature2_data_pos[1]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature2_pos_arr[feature2_data_pos[1]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)

                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature2_pos_arr[feature2_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            # else:
            #     feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            feature_xy = feature.geometry().asPoint()
            feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
            match_result_tmps.append([feature, matchResult])

        # delete_idxs = []
        # tong_ji_datas = {}
        # for index, match_tmp in enumerate(match_result_tmps):
        #     match_data = match_tmp[1]
        #     match_feature_id = match_data.featureid1()
        #     if match_feature_id in tong_ji_datas:
        #         if tong_ji_datas[match_feature_id][0] > match_data.featuredis():
        #             delete_idxs.append(tong_ji_datas[match_feature_id][1])
        #             tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]
        #         else:
        #             delete_idxs.append(index)
        #         continue
        #     tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]

        # tong_ji_datas = {}
        # for index, match_tmp in enumerate(match_result_tmps):
        #     if index in delete_idxs:
        #         continue

        #     match_data = match_tmp[1]
        #     match_feature_id = match_data.featureid2()
        #     if match_feature_id in tong_ji_datas:
        #         if tong_ji_datas[match_feature_id][0] > match_data.featuredis():
        #             delete_idxs.append(tong_ji_datas[match_feature_id][1])
        #             tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]
        #         else:
        #             delete_idxs.append(index)
        #         continue
        #     tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]

        for index, match_tmp in enumerate(match_result_tmps):
            # if index in delete_idxs:
            #     continue

            match_data = match_tmp[1]
            if match_data.featuremergetype() == 4:
                continue

            match_results.append(match_tmp[0])
        return match_results

    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    #通过2附属数据feature里面[name面]字段值来搜索对应[字段值_line]文件名,如果是gpkg则搜索对应图层名，来对文件进行一一对应
    def line_Arbitrary_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")

        vector_files = []
        if dataType == 0:
            for root, dirs, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".shp") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    file_datas = file_path.split(os.path.sep)
                    vector_files.append([file_datas[len(file_datas)-2], file_path])
        else:
            for root, _, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".gpkg") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    tf_name = splitext(split(file_path)[1])[0]
                    vector_files.append([tf_name, file_path])

        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]

        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(affiliation_layer.crs(), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")

        file_match_layers = {}
        for tf_name, vector_file in vector_files:
            if dataType == 0:
                file_name = splitext(split(vector_file)[1])[0]
                vector_layer = QgsVectorLayer(vector_file)
                if vector_layer.isValid() == False:
                    continue
                if vector_layer.geometryType() != QgsWkbTypes.LineGeometry:
                    continue
                file_match_layers[vector_layer] = [tf_name, file_name]
            else:
                layers = self.get_Gpkg_Layers(vector_file)
                for layer in layers:
                    if isinstance(layer, QgsVectorLayer) == False:
                        continue
                    if layer.geometryType() != QgsWkbTypes.LineGeometry:
                        continue
                    #path_splits = layer.name().split('_')
                    file_match_layers[layer] = [tf_name, tf_name]
        
        iterator = affiliation_layer.getFeatures()
        affiliation_id_match_layers = {}
        #通过feature与layer名字对应过滤一部分layer
        for feature in iterator:
            feature_geo = feature.geometry()
            feature_name_value = feature.attribute(self.nameField)
            match_layers = {}
            for tmp_match_layer in file_match_layers:   
                tf_name = file_match_layers[tmp_match_layer][0]
                file_name = file_match_layers[tmp_match_layer][1]
                if feature_name_value != tf_name:
                    continue
                match_layers[tmp_match_layer] = file_name
            if len(match_layers) > 0:
                affiliation_id_match_layers[feature.id()] = [match_layers, feature_geo, feature_name_value]

        #通过过滤之后的affiliation_id_match_layers获取layer计算layer与layer之间是否会有关系:
        match_layer_keys = []
        match_layer_values = []
        affiliation_feature_ids = []
        iterator = affiliation_layer.getFeatures()
        for feature in iterator:
            if feature.id() not in affiliation_id_match_layers:
                continue

            #affiliation_feature_ids.append(feature.id())    
            feature_geo = feature.geometry()
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for tmp_affiliation_id in affiliation_id_match_layers:
                if feature.id() == tmp_affiliation_id:
                    continue

                if buffer_geometry.intersects(affiliation_id_match_layers[tmp_affiliation_id][1]) == False:
                    continue
                
                if tmp_affiliation_id in match_layer_keys:
                    continue

                match_layer_keys.append(feature.id())
                match_layer_values.append(tmp_affiliation_id)

        layer_data_keys = match_layer_keys + match_layer_values
        for layer_data_key in layer_data_keys:
            if layer_data_key in affiliation_feature_ids:
                continue
            affiliation_feature_ids.append(layer_data_key)

        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "据附属文件没有匹配到任何图层")
            return True, ""
        
        dictFeatureIds = {}
        cur_step = 70.0 / len(affiliation_feature_ids)
        cur_future_prog = 0
        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = { executor.submit(self.split_data_by_feature, affiliation_id_match_layers, affiliation_feature_ids[n], affiliation_layer, isAffiliationMuti, False): n for n in range(len(affiliation_feature_ids)) }
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                aff_feature_id, feature_ids = future_data.result()
                dictFeatureIds[aff_feature_id] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            #QgsMessageLog.logMessage(str(len(match_layer_values)), 'aaa', level=Qgis.MessageLevel.Info)
            result_add_features = []
            step = 19.0 / len(match_layer_values)
            curprog = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_line_intersects, match_layer_keys[i], match_layer_values[i], config_dict, affiliation_id_match_layers, dictFeatureIds, distanceCalculator, isAffiliationMuti, dataType): i for i in range(len(match_layer_keys)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    result_add_features = result_add_features + future.result()
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 71), "")
                result_layer_name = 'AJ_line'
                source_layer_name = 'Point?' + result_layer_name
                result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                result_layer.setCrs(affiliation_layer.crs())
                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)
                result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                result_layer.updateFields()
                result_layer.startEditing()
                
                for i in range(len(result_add_features)):
                    result_layer.dataProvider().addFeature(result_add_features[i])
                result_layer.commitChanges()

                options = {}
                options['overwrite'] = True
                options['driverName'] = 'ESRI Shapefile'
                #options['driverName'] = 'GPKG'
                #options['layerName'] = 'my_out_table'
                QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")
        return True, ""

    def compute_polygon_intersects(self, featureid1, featureid2, config_dict, affiliation_layer, dictFeatureIds, dataType):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        
        match_results = []
        feature1_ids = dictFeatureIds[featureid1]
        feature2_ids = dictFeatureIds[featureid2]

        for data_layer1, feature1_id, file_name1 in feature1_ids:
            layer_name1 = data_layer1.name()
            if dataType == 0:
                layer_name1 = splitext(split(data_layer1.source())[1])[0]
            layer_ismuti1 = data_layer1.wkbType() == QgsWkbTypes.MultiPolygon or data_layer1.wkbType() == QgsWkbTypes.MultiPolygonZ or data_layer1.wkbType() == QgsWkbTypes.MultiPolygonZM
            feature_len = 0
            feature1 = data_layer1.getFeature(feature1_id)
            feature1_geometry = feature1.geometry()
            if layer_ismuti1:
                feature1_muti_poly = feature1_geometry.asMultiPolygon()
                for i in range(len(feature1_muti_poly)):
                    for j in range(len(feature1_muti_poly[i])):
                        feature_len = feature_len + len(feature1_muti_poly[i][j])
            else:
                feature_len = len(feature1_geometry.asPolygon())

            nodo_buffer_geo = feature1_geometry.buffer(factor * self.no_do_distance , feature_len)
            force_buffer_geo = feature1_geometry.buffer(factor * self.force_method_distance , feature_len)
            average_buffer_geo = feature1_geometry.buffer(factor * self.average_method_distance , feature_len)
            optimize_buffer_geo = feature1_geometry.buffer(factor * self.optimize_method_distance , feature_len)
            homeopathy_buffer_geo = feature1_geometry.buffer(factor * self.homeopathy_method_distance , feature_len)
            for data_layer2, feature2_id, file_name2 in feature2_ids:
                layer_name2 = data_layer2.name()
                if dataType == 0:
                    layer_name2 = splitext(split(data_layer2.source())[1])[0]                
                feature2 = data_layer2.getFeature(feature2_id)

                if (layer_name1 in config_dict and layer_name2 not in config_dict) \
                or (layer_name1 not in config_dict and layer_name2  in config_dict) \
                or (layer_name1 in config_dict and layer_name2 in config_dict and len(config_dict[layer_name1]) != len(config_dict[layer_name2])):
                    continue

                if layer_name1 in config_dict and layer_name2 in config_dict:
                    attribs1 = config_dict[layer_name1]
                    attribs2 = config_dict[layer_name2]

                    isEqual = True
                    for i in range(len(attribs1)):
                        if feature1.attribute(attribs1[i]) == feature2.attribute(attribs2[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线    
                feature2_geometry = feature2.geometry()
                #计算结果点
                mergeType = -1
                if homeopathy_buffer_geo.intersects(feature2_geometry):
                    mergeType = 3
                    if optimize_buffer_geo.intersects(feature2_geometry):
                        mergeType = 2
                        if average_buffer_geo.intersects(feature2_geometry):
                            mergeType = 1
                            if force_buffer_geo.intersects(feature2_geometry):
                                mergeType = 0
                                if nodo_buffer_geo.intersects(feature2_geometry):
                                    mergeType = -1
                if mergeType == -1:
                    continue

                mindis = 0.0
                intersection_geo = QgsPoint()
                if mergeType == 0:
                    intersection_geo = force_buffer_geo.intersection(feature2_geometry)
                    mindis = self.force_method_distance
                elif mergeType == 1:
                    intersection_geo = average_buffer_geo.intersection(feature2_geometry)
                    mindis = self.average_method_distance
                elif mergeType == 2:
                    intersection_geo = optimize_buffer_geo.intersection(feature2_geometry)
                    mindis = self.optimize_method_distance
                else:
                    intersection_geo = homeopathy_buffer_geo.intersection(feature2_geometry)
                    mindis = self.homeopathy_method_distance
                feature = QgsFeature()
                matchResult = matchResultFeatures(file_name1, layer_name1, feature1.id(), 0, 0, file_name2, layer_name2, feature2.id(), 0, 0, mergeType, dataType, mindis, self.scale)
                feature.setGeometry(intersection_geo.centroid())

                feature_xy = feature.geometry().asPoint()
                feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
                match_results.append(feature)
                break
        return match_results

    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    def polygon_Arbitrary_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")

        vector_files = []
        if dataType == 0:
            for root, dirs, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".shp") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    file_datas = file_path.split(os.path.sep)
                    vector_files.append([file_datas[len(file_datas)-2], file_path])
        else:
            for root, _, filenames in os.walk(inputDir):
                for filename in filenames:
                    if filename.endswith(".gpkg") == False:
                        continue
                    file_path = os.path.join(root, filename)
                    tf_name = splitext(split(file_path)[1])[0]
                    vector_files.append([tf_name, file_path])

        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]
        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(affiliation_layer.crs(), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")

        file_match_layers = {}
        for tf_name, vector_file in vector_files:
            if dataType == 0:
                file_name = splitext(split(vector_file)[1])[0]
                vector_layer = QgsVectorLayer(vector_file)
                if vector_layer.isValid() == False:
                    continue
                if vector_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
                    continue
                file_match_layers[vector_layer] = [tf_name, file_name]
            else:
                layers = self.get_Gpkg_Layers(vector_file)
                for layer in layers:
                    if isinstance(layer, QgsVectorLayer) == False:
                        continue
                    if layer.geometryType() != QgsWkbTypes.PolygonGeometry:
                        continue
                    #path_splits = layer.name().split('_')
                    file_match_layers[layer] = [tf_name, tf_name]
        
        iterator = affiliation_layer.getFeatures()
        affiliation_id_match_layers = {}
        #通过feature与layer名字对应过滤一部分layer
        for feature in iterator:
            feature_geo = feature.geometry()
            feature_name_value = feature.attribute(self.nameField)
            match_layers = {}
            for tmp_match_layer in file_match_layers:
                tf_name = file_match_layers[tmp_match_layer][0]
                file_name = file_match_layers[tmp_match_layer][1]
                if feature_name_value != tf_name:
                    continue
                match_layers[tmp_match_layer] = file_name
            if len(match_layers) > 0:
                affiliation_id_match_layers[feature.id()] = [match_layers, feature_geo, feature_name_value]


        #通过过滤之后的affiliation_id_match_layers获取layer计算layer与layer之间是否会有关系:
        match_layer_keys = []
        match_layer_values = []
        affiliation_feature_ids = []
        iterator = affiliation_layer.getFeatures()
        for feature in iterator:
            if feature.id() not in affiliation_id_match_layers:
                continue

            #affiliation_feature_ids.append(feature.id())    
            feature_geo = feature.geometry()
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for tmp_affiliation_id in affiliation_id_match_layers:
                if feature.id() == tmp_affiliation_id:
                    continue

                if buffer_geometry.intersects(affiliation_id_match_layers[tmp_affiliation_id][1]) == False:
                    continue
                
                if tmp_affiliation_id in match_layer_keys:
                    continue

                match_layer_keys.append(feature.id())
                match_layer_values.append(tmp_affiliation_id)
                
        layer_data_keys = match_layer_keys + match_layer_values
        for layer_data_key in layer_data_keys:
            if layer_data_key in affiliation_feature_ids:
                continue
            affiliation_feature_ids.append(layer_data_key)

        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "据附属文件没有匹配到任何图层")
            return True, ""
        
        dictFeatureIds = {}
        cur_step = 70.0 / len(affiliation_feature_ids)
        cur_future_prog = 0
        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = { executor.submit(self.split_data_by_feature, affiliation_id_match_layers, affiliation_feature_ids[n], affiliation_layer, isAffiliationMuti, False): n for n in range(len(affiliation_feature_ids)) }
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                aff_feature_id, feature_ids = future_data.result()
                dictFeatureIds[aff_feature_id] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            #QgsMessageLog.logMessage(str(len(match_layer_values)), 'aaa', level=Qgis.MessageLevel.Info)
            result_add_features = []
            step = 19.0 / len(match_layer_keys)
            curprog = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_polygon_intersects, match_layer_keys[i], match_layer_values[i], config_dict, affiliation_id_match_layers, dictFeatureIds, dataType): i for i in range(len(match_layer_keys)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    result_add_features = result_add_features + future.result()
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 71), "")

                result_layer_name = 'AJ_polygon'
                source_layer_name = 'Point?' + result_layer_name
                result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                result_layer.setCrs(affiliation_layer.crs())
                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)
                result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                result_layer.updateFields()
                result_layer.startEditing()
                
                for i in range(len(result_add_features)):
                    result_layer.dataProvider().addFeature(result_add_features[i])
                result_layer.commitChanges()

                options = {}
                options['overwrite'] = True
                options['driverName'] = 'ESRI Shapefile'
                #options['driverName'] = 'GPKG'
                #options['layerName'] = 'my_out_table'
                QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")
        return True, ""

    def split_border_data_by_feature(self, sub_data_array, aff_geo, isAffiliationMuti, border_name, layer_name, isPt):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)

        data_len = 0
        if isAffiliationMuti:
            feature_geo = aff_geo.asMultiPolygon()
            for i in range(len(feature_geo)):
                for j in range(len(feature_geo[i])):
                    data_len = data_len + len(feature_geo[i][j])
        else:
            data_len = len(feature_geo)

        affi_buffer_geometry = aff_geo.buffer(-factor * self.homeopathy_method_distance, data_len)
        affi_diff_geometry = aff_geo.difference(affi_buffer_geometry)

        intersect_ids = []
        data_feature_iterator = sub_data_array[1].getFeatures()
        for data_feature in data_feature_iterator:
            data_geometry = data_feature.geometry()
            if isPt:
                if affi_diff_geometry.contains(data_geometry) == False:
                    continue
            else:
                if affi_diff_geometry.intersects(data_geometry) == False:
                    continue
            intersect_ids.append(data_feature.id())     
        return border_name, layer_name, intersect_ids

    def compute_border_point_intersects(self, data_dict, geo_dict, operator_array, config_dict, distanceCalculator, isAffiliationMuti, dataType):
        tf_name1 = operator_array[0]
        tf_name2 = operator_array[1]
        layer_name = operator_array[2]

        affi_geo1 = geo_dict[tf_name1]
        attrib_layer_name1 = data_dict[tf_name1][layer_name][0]
        attrib_layer_name2 = data_dict[tf_name2][layer_name][0]

        match_results = []
        file_name1 = tf_name1
        file_name2 = tf_name2
        if dataType == 1:
            file_name1 = data_dict[tf_name1][layer_name][3]
            file_name2 = data_dict[tf_name2][layer_name][3]   
        feature1_ids = data_dict[tf_name1][layer_name][2]
        feature2_ids = data_dict[tf_name2][layer_name][2]
        layer_ismuti1 = data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPoint or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPointZ or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPointZM
        layer_ismuti2 = data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiPoint or data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiPointZ or data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiPointZM

        feature1_layer = data_dict[tf_name1][layer_name][1]
        feature2_layer = data_dict[tf_name2][layer_name][1]

        for feature1_id in feature1_ids:
            feature1 = feature1_layer.getFeature(feature1_id)
            feature_geometry1 = feature1.geometry()
            if layer_ismuti1:
                tmp_muti_poly = feature_geometry1.asMultiPoint()
                feature_geometry1 = QgsGeometry.fromPointXY(tmp_muti_poly[0])
            feature1_pt = feature_geometry1.asPoint()

            for feature2_id in feature2_ids:
                feature2 = feature2_layer.getFeature(feature2_id)
                if layer_name in config_dict:
                    attribs = config_dict[layer_name]
                    isEqual = True
                    for i in range(len(attribs)):
                        if feature1.attribute(attribs[i]) == feature2.attribute(attribs[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线    
                feature_geometry2 = feature2.geometry()
                if layer_ismuti2:
                    tmp_muti_poly = feature_geometry2.asMultiPoint()
                    feature_geometry2 = QgsGeometry.fromPointXY(tmp_muti_poly[0])

                feature2_pt = feature_geometry2.asPoint()
                pt_distance = distanceCalculator.measureLine(feature1_pt, feature2_pt) 
                #QgsMessageLog.logMessage(affiliation_layer[featureid1][0].source() + ',' + str(feature1.id()) + ',' + affiliation_layer[featureid2][0].source() + ',' + str(feature2.id()) + ',' + str(distances[min_value_index]), 'aaa', level=Qgis.MessageLevel.Info)
                #计算结果点
                mergeType = -1
                #强制法，平均法、优化法计算交点
                if pt_distance < self.no_do_distance:
                    mergeType = 4
                elif pt_distance < self.force_method_distance:
                    mergeType = 0
                elif pt_distance < self.average_method_distance:
                    mergeType = 1
                elif pt_distance < self.optimize_method_distance:
                    mergeType = 2
                elif pt_distance < self.homeopathy_method_distance:
                    mergeType = 3
                if mergeType == -1 or mergeType == 4:
                    continue

                feature = QgsFeature()
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), 0, 1, file_name2, attrib_layer_name2, feature2.id(), 0, 1, mergeType, dataType, pt_distance, self.scale)

                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(feature1_pt.x(), feature1_pt.y()), QgsPoint(feature2_pt.x(), feature2_pt.y())])
                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pt.x()/2+feature2_pt.x()/2,feature1_pt.y()/2 + feature2_pt.y()/2))

                feature_xy = feature.geometry().asPoint()
                feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
                match_results.append(feature)
                break
        return layer_name, match_results
    
    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    #通过2附属数据feature里面[tab]字段值来搜索对应[字段值_line]文件名,如果是gpkg则搜索对应图层名，来对文件进行一一对应
    def point_Border_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")
        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        data_dict_keys = []
        data_dict = {}
        geo_dict = {}
        aff_layer_feature = QgsFeature()

        if dataType == 0:
            for real_dir_name in os.listdir(inputDir):
                sub_dir_path = os.path.join(inputDir, real_dir_name)
                shp_paths = glob.glob(os.path.join(sub_dir_path, "*_point.shp"))
                for shp_file_path in shp_paths:
                    layer_name = splitext(split(shp_file_path)[1])[0]
                    path_splits = layer_name.split('_')
                    if len(path_splits) < 3:
                        continue

                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue

                    sub_layer = QgsVectorLayer(shp_file_path)
                    
                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [layer_name, sub_layer, [], layer_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()
        else:
            vector_files = glob.glob(os.path.join(inputDir, '*.gpkg'))
            for vector_file in vector_files:
                file_name = splitext(split(vector_file)[1])[0]
                layers = self.get_Gpkg_Layers(vector_file)
                vector_layers = [layer for layer in layers if isinstance(layer, QgsVectorLayer)]
                for vector_layer in vector_layers:
                    path_splits = vector_layer.name().split('_')
                    if len(path_splits) < 3 or path_splits[len(path_splits)-1] != 'point':
                        continue

                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue

                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [vector_layer.name(), vector_layer, [], file_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()
                    
        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]

        operator_array = []
        match_layer_keys = []
        match_layer_values = []
        for aff_geo_name in geo_dict:  
            feature_geo = geo_dict[aff_geo_name]
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for second_geo_name in geo_dict:
                if aff_geo_name == second_geo_name:
                    continue
                
                #不重复进行检查避免出现1:2和2:1同时出现的情况
                if second_geo_name in match_layer_keys:
                    continue

                if buffer_geometry.intersects(geo_dict[second_geo_name]) == False:
                    continue
                
                match_layer_keys.append(aff_geo_name)
                match_layer_values.append(second_geo_name)

                for first_border_layer_name in data_dict[aff_geo_name]:
                    for second_border_layer_name in data_dict[second_geo_name]:
                        if first_border_layer_name != second_border_layer_name:
                            continue
                        operator_array.append([aff_geo_name, second_geo_name, first_border_layer_name])
                
        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "据附属文件没有匹配到任何图层")
            return True, ""
        
        cur_step = 9.0 / len(data_dict_keys)
        cur_future_prog = 0

        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(affiliation_layer.crs(), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")

        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = {executor.submit(self.split_border_data_by_feature, data_dict[data_dict_key[0]][data_dict_key[1]], geo_dict[data_dict_key[0]], isAffiliationMuti, data_dict_key[0], data_dict_key[1], True) : data_dict_key for data_dict_key in data_dict_keys}
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                result_border_name, result_layer_name, feature_ids = future_data.result()
                data_dict[result_border_name][result_layer_name][2] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            #QgsMessageLog.logMessage(str(len(match_layer_values)), 'aaa', level=Qgis.MessageLevel.Info)
            result_add_features = {}
            step = 85.0 / len(operator_array)
            curprog = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_border_point_intersects, data_dict, geo_dict, operator_array[i], config_dict, distanceCalculator, isAffiliationMuti, dataType): i for i in range(len(operator_array)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    layer_name, result_datas = future.result()
                    if layer_name in result_add_features:
                        result_add_features[layer_name] = result_add_features[layer_name] + result_datas
                    else:
                        result_add_features[layer_name] = result_datas
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 10), "")
                
                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)
                for result_add_name in result_add_features:
                    result_layer_name = 'BJ_' + result_add_name
                    source_layer_name = 'Point?' + result_layer_name
                    result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                    result_layer.setCrs(affiliation_layer.crs())
                    #result_layer.dataProvider().setEncoding('utf-8')
                    result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                    result_layer.updateFields()
                    result_layer.startEditing()
                    
                    for element in result_add_features[result_add_name]:
                        result_layer.dataProvider().addFeature(element)
                    result_layer.commitChanges()

                    options = {}
                    options['overwrite'] = True
                    options['driverName'] = 'ESRI Shapefile'
                    #options['driverName'] = 'GPKG'
                    #options['layerName'] = 'my_out_table'
                    QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")
        return True, ""
    
    def compute_border_line_intersects(self, data_dict, geo_dict, operator_array, config_dict, distanceCalculator, isAffiliationMuti, dataType):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        tf_name1 = operator_array[0]
        tf_name2 = operator_array[1]
        layer_name = operator_array[2]
    
        affi_geo1 = geo_dict[tf_name1]
        affi_geo2 = geo_dict[tf_name2]
        attrib_layer_name1 = data_dict[tf_name1][layer_name][0]
        attrib_layer_name2 = data_dict[tf_name2][layer_name][0]

        match_results = []
        match_result_tmps = []
        feature1_ids = data_dict[tf_name1][layer_name][2]
        feature2_ids = data_dict[tf_name2][layer_name][2]

        file_name1 = tf_name1
        file_name2 = tf_name2
        if dataType == 1:
            file_name1 = data_dict[tf_name1][layer_name][3]
            file_name2 = data_dict[tf_name2][layer_name][3]        
        layer_ismuti1 = data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiLineString or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiLineStringZ or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiLineStringZM
        layer_ismuti2 = data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiLineString or data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiLineStringZ or data_dict[tf_name2][layer_name][1].wkbType() == QgsWkbTypes.MultiLineStringZM

        feature1_layer = data_dict[tf_name1][layer_name][1]
        feature2_layer = data_dict[tf_name2][layer_name][1]

        res_feature1_first_pt = None
        res_feature1_second_pt = None
        res_feature1_last_pt = None
        res_feature1_selast_pt = None

        res_feature2_first_pt = None
        res_feature2_second_pt = None
        res_feature2_last_pt = None
        res_feature2_selast_pt = None
        for feature1_id in feature1_ids:
            feature1 = feature1_layer.getFeature(feature1_id)
            feature_min_dis = sys.float_info.max

            feature1_index = 0
            feature2_cur_id = 0
            feature2_index = 0
            mergeType = -1
            res_min_value_index = 0
            for feature2_id in feature2_ids:
                feature2 = feature2_layer.getFeature(feature2_id)
                if layer_name in config_dict:
                    attribs = config_dict[layer_name]

                    isEqual = True
                    for i in range(len(attribs)):
                        if feature1.attribute(attribs[i]) == feature2.attribute(attribs[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线
                feature1_line_list = []
                feature_geometry1 = feature1.geometry()
                if layer_ismuti1:
                    tmp_muti_polys = feature_geometry1.asMultiPolyline()
                    for tmp_muti_poly in tmp_muti_polys:
                        feature1_line_list.append(tmp_muti_poly)
                else:
                    feature1_line_list.append(feature_geometry1.asPolyline())

                feature2_line_list = []
                feature_geometry2 = feature2.geometry()
                if layer_ismuti2:
                    tmp_muti_polys = feature_geometry2.asMultiPolyline()
                    for tmp_muti_poly in tmp_muti_polys:
                        feature2_line_list.append(tmp_muti_poly)
                else:
                    feature2_line_list.append(feature_geometry2.asPolyline())

                for i in range(len(feature1_line_list)):
                    for j in range(len(feature2_line_list)):
                        feature1_pt_list = feature1_line_list[i]
                        feature2_pt_list = feature2_line_list[j]

                        feature1_first_pt = feature1_pt_list[0]
                        #feature1_second_pt = feature1_pt_list[1]
                        feature1_last_pt = feature1_pt_list[len(feature1_pt_list) - 1]
                        #feature1_selast_pt = feature1_pt_list[len(feature1_pt_list) - 2]

                        feature2_first_pt = feature2_pt_list[0]
                        #feature2_second_pt = feature2_pt_list[1]
                        feature2_last_pt = feature2_pt_list[len(feature2_pt_list) - 1]
                        #feature2_selast_pt = feature2_pt_list[len(feature2_pt_list) - 2]

                        distance1 = distanceCalculator.measureLine([feature1_first_pt, feature2_first_pt])
                        distance2 = distanceCalculator.measureLine([feature1_last_pt, feature2_first_pt])
                        distance3 = distanceCalculator.measureLine([feature1_first_pt, feature2_last_pt])
                        distance4 = distanceCalculator.measureLine([feature1_last_pt, feature2_last_pt])
                        distances = [distance1, distance2, distance3, distance4]
                        min_value_index = min(range(len(distances)), key=distances.__getitem__)
                        
                        if distances[min_value_index] >= self.homeopathy_method_distance or distances[min_value_index] >= feature_min_dis:
                            continue
                        
                        res_min_value_index = min_value_index
                        feature_min_dis = distances[min_value_index]
                        feature1_index = i
                        feature2_cur_id = feature2.id()
                        feature2_index = j
                        res_feature1_first_pt = feature1_pt_list[0]
                        res_feature1_second_pt = feature1_pt_list[1]
                        res_feature1_last_pt = feature1_pt_list[len(feature1_pt_list) - 1]
                        res_feature1_selast_pt = feature1_pt_list[len(feature1_pt_list) - 2]

                        res_feature2_first_pt = feature2_pt_list[0]
                        res_feature2_second_pt = feature2_pt_list[1]
                        res_feature2_last_pt = feature2_pt_list[len(feature2_pt_list) - 1]
                        res_feature2_selast_pt = feature2_pt_list[len(feature2_pt_list) - 2]
                        #强制法，平均法、优化法计算交点
                        if feature_min_dis < self.no_do_distance:
                            mergeType = 4
                        elif feature_min_dis < self.force_method_distance:
                            mergeType = 0
                        elif feature_min_dis < self.average_method_distance:
                            mergeType = 1
                        elif feature_min_dis < self.optimize_method_distance:
                            mergeType = 2
                        elif feature_min_dis < self.homeopathy_method_distance:
                            mergeType = 3
                        else:
                            continue
                    # if is_find:
                    #     feature1_index = i
                    #     break

            if mergeType == -1:
                continue  

            feature = QgsFeature()
            matchResult = None
            feature1_pos_arr = [res_feature1_first_pt, res_feature1_second_pt, res_feature1_last_pt, res_feature1_selast_pt]
            feature2_pos_arr = [res_feature2_first_pt, res_feature2_second_pt, res_feature2_last_pt, res_feature2_selast_pt]

            feature1_data_pos = []
            feature2_data_pos = []
            if res_min_value_index == 0:
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), feature1_index, 0, \
                                                    file_name2, attrib_layer_name2, feature2_cur_id, feature2_index, 0, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [1, 0]
                feature2_data_pos = [1, 0]
            elif res_min_value_index == 1:
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), feature1_index, 1, \
                                                    file_name2, attrib_layer_name2, feature2_cur_id, feature2_index, 0, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [3, 2]
                feature2_data_pos = [1, 0]
            elif res_min_value_index == 2:
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), feature1_index, 0, \
                                                    file_name2, attrib_layer_name2, feature2_cur_id, feature2_index, 1, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [1, 0]
                feature2_data_pos = [3, 2]
            else:
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), feature1_index, 1, \
                                                    file_name2, attrib_layer_name2, feature2_cur_id, feature2_index, 1, \
                                                    mergeType, dataType, feature_min_dis, self.scale)
                feature1_data_pos = [3, 2]
                feature2_data_pos = [3, 2]

            if mergeType == 0:
                dx = feature1_pos_arr[feature1_data_pos[0]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature1_pos_arr[feature1_data_pos[0]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)

                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature1_pos_arr[feature1_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            elif mergeType == 1:
                #计算第一条线与面的交点
                intert_geo0 = QgsPoint()
                dx = feature1_pos_arr[feature1_data_pos[0]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature1_pos_arr[feature1_data_pos[0]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)
                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature1_pos_arr[feature1_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多线
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            #QgsMessageLog.logMessage(str(intert_geo.x()) + "," + str(intert_geo.y()), 'aaa', level=Qgis.MessageLevel.Info)
                            intert_geo0 = QgsPoint(intert_geo.x(),intert_geo.y())
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        intert_geo0 = QgsPoint(intert_geo.x(),intert_geo.y())
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    intert_geo0 = QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2)
                
                #计算第二条线与面的交点
                dx = feature2_pos_arr[feature2_data_pos[0]].x() - feature2_pos_arr[feature2_data_pos[1]].x()
                dy = feature2_pos_arr[feature2_data_pos[0]].y() - feature2_pos_arr[feature2_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)
                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature2_pos_arr[feature2_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature2_pos_arr[feature2_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo2.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue

                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x()/2 + intert_geo0.x()/2, intert_geo.y()/2 + intert_geo0.y()/2))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo2.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x()/2 + intert_geo0.x()/2, intert_geo.y()/2 + intert_geo0.y()/2))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            elif mergeType == 4:
                feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            else: #顺势法不做处理，但是点所在位置按照优化法计算
                #优化法
                dx = feature2_pos_arr[feature2_data_pos[1]].x() - feature1_pos_arr[feature1_data_pos[1]].x()
                dy = feature2_pos_arr[feature2_data_pos[1]].y() - feature1_pos_arr[feature1_data_pos[1]].y()
                ds = math.sqrt(dx*dx+dy*dy)

                #把线两边延伸
                firstx = -factor * self.homeopathy_method_distance * dx / ds + feature1_pos_arr[feature1_data_pos[1]].x()
                firsty = -factor * self.homeopathy_method_distance * dy / ds +feature1_pos_arr[feature1_data_pos[1]].y()
                lastx = factor * self.homeopathy_method_distance * dx / ds + feature2_pos_arr[feature2_data_pos[0]].x()
                lasty = factor * self.homeopathy_method_distance * dy / ds + feature2_pos_arr[feature2_data_pos[0]].y()
                intertert_polyline = QgsGeometry.fromPolyline([QgsPoint(firstx,firsty), QgsPoint(lastx, lasty)])

                if isAffiliationMuti:
                    #多面
                    is_instertion_find = False
                    parts = affi_geo1.asMultiPolygon()
                    for part in parts:
                        for ring in part:
                            # 将环转换为线
                            intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                            if intertert_geo.isEmpty():
                                continue
                            intert_geo = intertert_geo.centroid().asPoint()
                            #设置交点
                            feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                            is_instertion_find = True
                            break
                        if is_instertion_find:
                            break
                else:
                    #非多面
                    parts = affi_geo1.asPolygon()
                    for ring in parts:
                        # 将环转换为线
                        intertert_geo = intertert_polyline.intersection(QgsGeometry.fromPolylineXY(ring))
                        if intertert_geo.isEmpty():
                                continue
                        intert_geo = intertert_geo.centroid().asPoint()
                        #设置交点
                        feature.setGeometry(QgsPoint(intert_geo.x(),intert_geo.y()))
                        is_instertion_find = True
                        break
                if is_instertion_find == False:
                    feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
                # else:
                #     feature.setGeometry(QgsPoint(feature1_pos_arr[feature1_data_pos[1]].x()/2 + feature2_pos_arr[feature2_data_pos[1]].x()/2,feature1_pos_arr[feature1_data_pos[1]].y()/2 + feature2_pos_arr[feature2_data_pos[1]].y()/2))
            feature_xy = feature.geometry().asPoint()
            feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
            match_result_tmps.append([feature, matchResult])
        
        delete_idxs = []
        tong_ji_datas = {}
        for index, match_tmp in enumerate(match_result_tmps):
            match_data = match_tmp[1]
            match_feature_id = match_data.featureid1()
            if match_feature_id in tong_ji_datas:
                if tong_ji_datas[match_feature_id][0] > match_data.featuredis():
                    delete_idxs.append(tong_ji_datas[match_feature_id][1])
                    tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]
                else:
                    delete_idxs.append(index)
                continue
            tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]

        tong_ji_datas = {}
        for index, match_tmp in enumerate(match_result_tmps):
            if index in delete_idxs:
                continue

            match_data = match_tmp[1]
            match_feature_id = match_data.featureid2()
            if match_feature_id in tong_ji_datas:
                if tong_ji_datas[match_feature_id][0] > match_data.featuredis():
                    delete_idxs.append(tong_ji_datas[match_feature_id][1])
                    tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]
                else:
                    delete_idxs.append(index)
                continue
            tong_ji_datas[match_feature_id] = [match_data.featuredis(), index]

        for index, match_tmp in enumerate(match_result_tmps):
            if index in delete_idxs:
                continue

            match_data = match_tmp[1]
            if match_data.featuremergetype() == 4:
                continue

            match_results.append(match_tmp[0])
        #优化输出,去掉同一feature_layer_id,然后去掉mergeType为4的记录

        return layer_name, match_results
    
    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    #通过2附属数据feature里面[tab]字段值来搜索对应[字段值_line]文件名,如果是gpkg则搜索对应图层名，来对文件进行一一对应
    def line_Border_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")
        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        data_dict_keys = []
        data_dict = {}
        geo_dict = {}
        aff_layer_feature = QgsFeature()

        if dataType == 0:
            for real_dir_name in os.listdir(inputDir):
                sub_dir_path = os.path.join(inputDir, real_dir_name)
                shp_paths = glob.glob(os.path.join(sub_dir_path, "*_line.shp"))
                for shp_file_path in shp_paths:
                    layer_name = splitext(split(shp_file_path)[1])[0]
                    path_splits = layer_name.split('_')
                    if len(path_splits) < 3:
                        continue
                   
                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}                    
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue

                    sub_layer = QgsVectorLayer(shp_file_path)
                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [layer_name, sub_layer, [], layer_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()
        else:
            vector_files = glob.glob(os.path.join(inputDir, '*.gpkg'))
            for vector_file in vector_files:
                file_name = splitext(split(vector_file)[1])[0]
                layers = self.get_Gpkg_Layers(vector_file)
                vector_layers = [layer for layer in layers if isinstance(layer, QgsVectorLayer)]
                for vector_layer in vector_layers:
                    path_splits = vector_layer.name().split('_')
                    if len(path_splits) < 3 or path_splits[len(path_splits)-1] != 'line':
                        continue

                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}                    
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue
                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [vector_layer.name(), vector_layer, [], file_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()

        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]

        operator_array = []
        match_layer_keys = []
        match_layer_values = []
        for aff_geo_name in geo_dict:  
            feature_geo = geo_dict[aff_geo_name]
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for second_geo_name in geo_dict:
                if aff_geo_name == second_geo_name:
                    continue
                
                #不重复进行检查避免出现1:2和2:1同时出现的情况
                if second_geo_name in match_layer_keys:
                    continue

                if buffer_geometry.intersects(geo_dict[second_geo_name]) == False:
                    continue
                
                match_layer_keys.append(aff_geo_name)
                match_layer_values.append(second_geo_name)

                for first_border_layer_name in data_dict[aff_geo_name]:
                    for second_border_layer_name in data_dict[second_geo_name]:
                        if first_border_layer_name != second_border_layer_name:
                            continue
                        operator_array.append([aff_geo_name, second_geo_name, first_border_layer_name])
                
        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "据附属文件没有匹配到任何图层")
            return True, ""
        
        cur_step = 9.0 / len(data_dict_keys)
        cur_future_prog = 0

        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")

        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = {executor.submit(self.split_border_data_by_feature, data_dict[data_dict_key[0]][data_dict_key[1]], geo_dict[data_dict_key[0]], isAffiliationMuti, data_dict_key[0], data_dict_key[1], False) : data_dict_key for data_dict_key in data_dict_keys}
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                result_border_name, result_layer_name, feature_ids = future_data.result()
                data_dict[result_border_name][result_layer_name][2] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            result_add_features = {}
            step = 85.0 / len(operator_array)
            curprog = 0
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_border_line_intersects, data_dict, geo_dict, operator_array[i], config_dict, distanceCalculator, isAffiliationMuti, dataType): i for i in range(len(operator_array)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    layer_name, result_datas = future.result()
                    if layer_name in result_add_features:
                        result_add_features[layer_name] = result_add_features[layer_name] + result_datas
                    else:
                        result_add_features[layer_name] = result_datas
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 10), "")

                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)

                for result_add_name in result_add_features:
                    if len(result_add_features[result_add_name]) == 0:
                        curprog = curprog + 1
                        self.progress_signal.emit((int)(step * curprog + 90), "")
                        continue
                    result_layer_name = 'BJ_' + result_add_name
                    source_layer_name = 'Point?' + result_layer_name
                    result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                    result_layer.setCrs(affiliation_layer.crs())
                    #result_layer.dataProvider().setEncoding('utf-8')
                    result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                    result_layer.updateFields()
                    result_layer.startEditing()
                    
                    for element in result_add_features[result_add_name]:
                        result_layer.dataProvider().addFeature(element)  
                    result_layer.commitChanges()

                    options = {}
                    options['overwrite'] = True
                    options['driverName'] = 'ESRI Shapefile'
                    #options['Encoding'] = 'UTF-8'
                    #options['driverName'] = 'GPKG'
                    #options['layerName'] = 'my_out_table'
                    QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")
        return True, ""
    

    def compute_border_polygon_intersects(self, data_dict, operator_array, config_dict, dataType):
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        tf_name1 = operator_array[0]
        tf_name2 = operator_array[1]
        layer_name = operator_array[2]

        attrib_layer_name1 = data_dict[tf_name1][layer_name][0]
        attrib_layer_name2 = data_dict[tf_name2][layer_name][0]

        #一个包含属性一个不包含直接return
        # if (attrib_layer_name1 in config_dict and attrib_layer_name2 not in config_dict) \
        # or (attrib_layer_name1 not in config_dict and attrib_layer_name2  in config_dict) \
        # or (attrib_layer_name1 in config_dict and attrib_layer_name2 in config_dict and len(config_dict[attrib_layer_name1]) != len(config_dict[attrib_layer_name2])):
        #     return layer_name, []

        match_results = []
        feature1_ids = data_dict[tf_name1][layer_name][2]
        feature2_ids = data_dict[tf_name2][layer_name][2]
        file_name1 = tf_name1
        file_name2 = tf_name2
        if dataType == 1:
            file_name1 = data_dict[tf_name1][layer_name][3]
            file_name2 = data_dict[tf_name2][layer_name][3]       
        layer_ismuti1 = data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPolygon or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPolygonZ or data_dict[tf_name1][layer_name][1].wkbType() == QgsWkbTypes.MultiPolygonZM
        feature1_layer = data_dict[tf_name1][layer_name][1]
        feature2_layer = data_dict[tf_name2][layer_name][1]

        for feature1_id in feature1_ids:
            feature_len = 0
            feature1 = feature1_layer.getFeature(feature1_id)
            feature1_geometry = feature1.geometry()
            if layer_ismuti1:
                feature1_muti_poly = feature1_geometry.asMultiPolygon()
                for i in range(len(feature1_muti_poly)):
                    for j in range(len(feature1_muti_poly[i])):
                        feature_len = feature_len + len(feature1_muti_poly[i][j])
            else:
                feature_len = len(feature1_geometry.asPolygon())

            nodo_buffer_geo = feature1_geometry.buffer(factor * self.no_do_distance , feature_len)
            force_buffer_geo = feature1_geometry.buffer(factor * self.force_method_distance , feature_len)
            average_buffer_geo = feature1_geometry.buffer(factor * self.average_method_distance , feature_len)
            optimize_buffer_geo = feature1_geometry.buffer(factor * self.optimize_method_distance , feature_len)
            homeopathy_buffer_geo = feature1_geometry.buffer(factor * self.homeopathy_method_distance , feature_len)
            for feature2_id in feature2_ids:
                feature2 = feature2_layer.getFeature(feature2_id)
                if layer_name in config_dict:
                    attribs = config_dict[layer_name]
                    # attribs2 = config_dict[attrib_layer_name2]

                    isEqual = True
                    for i in range(len(attribs)):
                        if feature1.attribute(attribs[i]) == feature2.attribute(attribs[i]):
                            continue
                        isEqual = False
                        break

                    if isEqual == False:
                        continue

                #多线转单线    
                feature2_geometry = feature2.geometry()
                #计算结果点
                mergeType = -1
                if homeopathy_buffer_geo.intersects(feature2_geometry):
                    mergeType = 3
                    if optimize_buffer_geo.intersects(feature2_geometry):
                        mergeType = 2
                        if average_buffer_geo.intersects(feature2_geometry):
                            mergeType = 1
                            if force_buffer_geo.intersects(feature2_geometry):
                                mergeType = 0
                                if nodo_buffer_geo.intersects(feature2_geometry):
                                    mergeType = -1
                
                if mergeType == -1:
                    continue

                mindis = 0.0   
                intersection_geo = QgsPoint()
                if mergeType == 0:
                    intersection_geo = force_buffer_geo.intersection(feature2_geometry)
                    mindis = self.force_method_distance
                elif mergeType == 1:
                    intersection_geo = average_buffer_geo.intersection(feature2_geometry)
                    mindis = self.average_method_distance
                elif mergeType == 2:
                    intersection_geo = optimize_buffer_geo.intersection(feature2_geometry)
                    mindis = self.optimize_method_distance
                else:
                    intersection_geo = homeopathy_buffer_geo.intersection(feature2_geometry)
                    mindis = self.homeopathy_method_distance
                feature = QgsFeature()
                matchResult = matchResultFeatures(file_name1, attrib_layer_name1, feature1.id(), 0, 0, file_name2, attrib_layer_name2, feature2.id(), 0, 0, mergeType, dataType, mindis, self.scale)
                feature.setGeometry(intersection_geo.centroid())
                feature_xy = feature.geometry().asPoint()
                feature.setAttributes([matchResult.distance, matchResult.distance * 1000 /self.scale, matchResult.operString(), self.scale, feature_xy.x(), feature_xy.y(), None, matchResult.toString()])
                match_results.append(feature)
                break

        return layer_name, match_results

    #1输入数据目录 string
    #2附属数据路径 string
    #3配置文件路径 string
    #4结果目录 string
    #5数据类型 int 0 shp 1 gpkg
    #通过2附属数据feature里面[tab]字段值来搜索对应[字段值_line]文件名,如果是gpkg则搜索对应图层名，来对文件进行一一对应
    def polygon_Border_Edge_Check(self, inputDir, affiliationFilePath, configFilePath, resultDir, dataType):
        self.progress_signal.emit(1, "")
        affiliation_layer = QgsVectorLayer(affiliationFilePath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        data_dict_keys = []
        data_dict = {}
        geo_dict = {}
        aff_layer_feature = QgsFeature()

        if dataType == 0:
            for real_dir_name in os.listdir(inputDir):
                sub_dir_path = os.path.join(inputDir, real_dir_name)
                shp_files = glob.glob(os.path.join(sub_dir_path, "*_polygon.shp"))
                for shp_file_path in shp_files:
                    layer_name = splitext(split(shp_file_path)[1])[0]
                    path_splits = layer_name.split('_')
                    if len(path_splits) < 3:
                        continue
                    
                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}  
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue

                    sub_layer = QgsVectorLayer(shp_file_path)
                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [layer_name, sub_layer, [], layer_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()
        else:
            vector_files = glob.glob(os.path.join(inputDir, '*.gpkg'))
            for vector_file in vector_files:
                file_name = splitext(split(vector_file)[1])[0]
                layers = self.get_Gpkg_Layers(vector_file)
                vector_layers = [layer for layer in layers if isinstance(layer, QgsVectorLayer)]
                for vector_layer in vector_layers:
                    path_splits = vector_layer.name().split('_')
                    if len(path_splits) < 3 or path_splits[len(path_splits)-1] != 'polygon':
                        continue

                    tf_name = path_splits[0]
                    if tf_name not in data_dict:
                        data_dict[tf_name] = {}  
                    layer_request = QgsFeatureRequest().setFilterExpression(self.nameField + " = '" + tf_name + "'")
                    layer_feature_iter = affiliation_layer.getFeatures(layer_request)
                    if layer_feature_iter.nextFeature(aff_layer_feature) == False:
                        continue

                    filter_layer_name = path_splits[1]
                    for i in range(2, len(path_splits)):
                        filter_layer_name = filter_layer_name + '_' + path_splits[i]
                    data_dict[tf_name][filter_layer_name] = [vector_layer.name(), vector_layer, [], file_name]
                    data_dict_keys.append([tf_name, filter_layer_name])
                    geo_dict[tf_name] = aff_layer_feature.geometry()

        isAffiliationMuti = affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygon or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZ or affiliation_layer.wkbType() == QgsWkbTypes.MultiPolygonZM
        factor = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, QgsUnitTypes.DistanceDegrees)
        config_dict = {}
        with open(configFilePath, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                config_fields = line.strip().split(",")
                if len(config_fields) <= 1:
                    continue
                config_dict[config_fields[0]] = config_fields[1:]

        operator_array = []
        match_layer_keys = []
        match_layer_values = []
        for aff_geo_name in geo_dict:  
            feature_geo = geo_dict[aff_geo_name]
            feature_len = 0
            if isAffiliationMuti:
                feature_geo_polygon = feature_geo.asMultiPolygon()
                for i in range(len(feature_geo_polygon)):
                    for j in range(len(feature_geo_polygon[i])):
                        feature_len += len(feature_geo_polygon[i][j])
            else:
                feature_len = len(feature_geo.asPolyline())

            #向外缓冲顺势法距离
            buffer_geometry = feature_geo.buffer(factor * self.homeopathy_method_distance, feature_len)
            for second_geo_name in geo_dict:
                if aff_geo_name == second_geo_name:
                    continue
                
                #不重复进行检查避免出现1:2和2:1同时出现的情况
                if second_geo_name in match_layer_keys:
                    continue

                if buffer_geometry.intersects(geo_dict[second_geo_name]) == False:
                    continue
                
                match_layer_keys.append(aff_geo_name)
                match_layer_values.append(second_geo_name)

                for first_border_layer_name in data_dict[aff_geo_name]:
                    for second_border_layer_name in data_dict[second_geo_name]:
                        if first_border_layer_name != second_border_layer_name:
                            continue
                        operator_array.append([aff_geo_name, second_geo_name, first_border_layer_name])
                
        if len(match_layer_values) == 0:
            self.progress_signal.emit(100, "据附属文件没有匹配到任何图层")
            return True, ""
        
        cur_step = 9.0 / len(data_dict_keys)
        cur_future_prog = 0

        distanceCalculator = QgsDistanceArea()
        distanceCalculator.setSourceCrs(affiliation_layer.crs(), QgsProject.instance().transformContext())
        distanceCalculator.setEllipsoid("WGS84")
        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            buffer_to_task = {executor.submit(self.split_border_data_by_feature, data_dict[data_dict_key[0]][data_dict_key[1]], geo_dict[data_dict_key[0]], isAffiliationMuti, data_dict_key[0], data_dict_key[1], False) : data_dict_key for data_dict_key in data_dict_keys}
        
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(buffer_to_task):
                result_border_name, result_layer_name, feature_ids = future_data.result()
                data_dict[result_border_name][result_layer_name][2] = feature_ids
                cur_future_prog = cur_future_prog + 1
                self.progress_signal.emit((int)(cur_step * cur_future_prog + 1), "")

            #并发计算图层间关系
            #QgsMessageLog.logMessage(str(len(match_layer_values)), 'aaa', level=Qgis.MessageLevel.Info)
            result_add_features = {}
            step = 85.0 / len(operator_array)
            curprog = 0

            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.compute_border_polygon_intersects, data_dict, operator_array[i], config_dict, dataType): i for i in range(len(operator_array)) }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    layer_name, result_datas = future.result()
                    if layer_name in result_add_features:
                        result_add_features[layer_name] = result_add_features[layer_name] + result_datas
                    else:
                        result_add_features[layer_name] = result_datas
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 10), "")
                
                newField1 = QgsField('L_m', QVariant.Double)
                newField2 = QgsField('P_mm', QVariant.Double)
                newField3 = QgsField('val', QVariant.String, len=10)
                newField4 = QgsField('scale', QVariant.Int)
                newField5 = QgsField('current_x', QVariant.Double)
                newField6 = QgsField('current_y', QVariant.Double)
                newField7 = QgsField('describe', QVariant.String, len=20)
                newField8 = QgsField('remarks', QVariant.String, len=256)
                for result_add_name in result_add_features:
                    result_layer_name = 'BJ_' + result_add_name
                    source_layer_name = 'Point?' + result_layer_name
                    result_layer = QgsVectorLayer(source_layer_name, result_layer_name, 'memory')
                    result_layer.setCrs(affiliation_layer.crs())
                    result_layer.dataProvider().addAttributes([newField1, newField2, newField3, newField4, newField5, newField6, newField7, newField8])
                    result_layer.updateFields()
                    result_layer.startEditing()
                    
                    for element in result_add_features[result_add_name]:
                        result_layer.dataProvider().addFeature(element)
                    result_layer.commitChanges()

                    options = {}
                    options['overwrite'] = True
                    options['driverName'] = 'ESRI Shapefile'
                    #options['driverName'] = 'GPKG'
                    #options['layerName'] = 'my_out_table'
                    QgsVectorLayerExporter.exportLayer(result_layer, resultDir + "/" + result_layer_name + ".shp", 'ogr', result_layer.crs(), False, options)
                self.progress_signal.emit(100, "完成")
        return True, ""

#firstIsLast,secondIsLast为int型,线要素时有用，0表示为头部,1表示为尾部, mergeType结果0强制法,1平均法,2优化法,3顺势法
class matchResultFeatures:
    def __init__(self, fileName1, layerName1, featureID1, part1, isLast1, fileName2, layerName2, featureID2, part2, isLast2, mergeType, dataType, distance, scale):
        self.fileName1 = fileName1
        self.layerName1 = layerName1
        self.featureID1 = featureID1
        self.part1 = part1
        self.isLast1 = isLast1
        self.fileName2 = fileName2
        self.layerName2 = layerName2
        self.featureID2 = featureID2
        self.part2 = part2
        self.isLast2 = isLast2
        self.mergeType = mergeType
        self.dataType = dataType #0shp 1gpkg
        self.distance = distance
        self.scale = scale
    
    def operString(self):
        if self.mergeType == 0:
            return '强制法'
        elif self.mergeType == 1:
            return '平均法'
        elif self.mergeType == 2:
            return '优化法'
        elif self.mergeType == 4:
            return ''
        return '不处理'

    def toString(self):
        separator = ","
        result_strings = [self.fileName1, self.layerName1, str(self.featureID1), str(self.part1), str(self.isLast1), \
                        self.fileName2, self.layerName2, str(self.featureID2), str(self.part2),str(self.isLast2), \
                        str(self.mergeType), str(self.dataType)]
        result = separator.join(result_strings)
        return result
    
    def featureid1(self):
        return self.featureID1

    def featureid2(self):
        return self.featureID2

    def featuredis(self):
        return self.distance

    def featuremergetype(self):
        return self.mergeType