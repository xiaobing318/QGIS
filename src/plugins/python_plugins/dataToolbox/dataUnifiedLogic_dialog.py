# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dataFormatConvertDialog
                                 A QGIS plugin
 dataFormatConvert
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-01-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by xing qiu
        email                : xing qiu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt import uic, QtWidgets
from threading import Thread
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from PyQt5.QtCore import QThread, pyqtSignal, QVariant, QSettings, QVariant
from qgis.core import QgsRasterLayer,Qgis, QgsMessageLog, QgsVectorLayerExporter, QgsProject, QgsRasterResampler, QgsCoordinateReferenceSystem, QgsUnitTypes, QgsVectorLayer, QgsField, QgsPoint, QgsFeature, QgsGeometry, QgsVectorFileWriter,QgsCoordinateTransform
from osgeo import gdal, gdalconst, ogr
import numpy as np
import statistics
import shutil
import subprocess
import concurrent.futures
from osgeo import osr

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dataUnifiedLogic_dialog_base.ui'))


class dataUnifiedLogicDialog(QtWidgets.QDialog, FORM_CLASS):
    detection_progress_signal = pyqtSignal(int, str)
    correct_progress_signal = pyqtSignal(int, str)

    def __init__(self, parent=None, showDlg=True):
        """Constructor."""
        super(dataUnifiedLogicDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.showDlg = showDlg
        self.threshold = 150 #设置陆水的高程值阈值
        self.max_thread_num = 100
        self.search_radius_pixel = 5 #初始搜索像素范围
        self.default_water_value = 0 #水默认值

        #高程检测
        #浏览数据目录
        self.detectionTifButton.clicked.connect(self.detection_data_path_clicked)
        #浏览数据目录
        self.detectionLandButton.clicked.connect(self.detection_land_path_clicked)
        #设置保存数据
        self.detectionShpButton.clicked.connect(self.detection_data_op_clicked)
        #开始转换处理
        self.detectionButton.clicked.connect(self.detection_process_button_clicked)
        #关闭对话框
        self.detectionCloseButton.clicked.connect(self.on_close_button_clicked)

        #高程校正
        #浏览数据目录
        self.correctTifButton.clicked.connect(self.correct_data_path_clicked)
        #浏览数据目录
        self.correctShpButton.clicked.connect(self.correct_path_clicked)
        #设置保存数据
        self.correctSaveButton.clicked.connect(self.correct_data_op_clicked)
        #开始转换处理
        self.correctButton.clicked.connect(self.correct_process_button_clicked)
        #关闭对话框
        self.correctCloseButton.clicked.connect(self.on_close_button_clicked)

        self.settings = QSettings('XingqiuCompany', 'dataUnifiedLogic')
        self.detectionInputTif.setText(self.settings.value('detection_data_path', ''))
        self.detectionInputLand.setText(self.settings.value('detection_land_path', ''))
        self.detectionOutputShp.setText(self.settings.value('detection_save_path', ''))

        self.correctInputTif.setText(self.settings.value('correct_data_path', ''))
        self.correctInputShp.setText(self.settings.value('correct_shp_path', ''))
        self.correctOutputTif.setText(self.settings.value('correct_save_path', ''))

        self.detection_progress_signal.connect(self.detection_connect_fun)
        self.correct_progress_signal.connect(self.correct_connect_fun)

    def detection_connect_fun(self, prog, msg_data):
        if self.showDlg:
            self.detectionProgressBar.setValue(prog)
        else:
            print("当前进度:" + str(prog) + "%")

        if prog >= 100:
            if self.showDlg:
                QMessageBox.information(None, '提示', msg_data)
            else:
                print("运行完成！")

    def correct_connect_fun(self, prog, msg_data):
        if self.showDlg:
            self.correctProgressBar.setValue(prog)
        else:
            print("当前进度:" + str(prog) + "%")

        if prog >= 100:
            if self.showDlg:
                QMessageBox.information(None, '提示', msg_data)
            else:
                print("运行完成！")

    def detection_data_path_clicked(self):
        input_tif_path, _ = QFileDialog.getOpenFileName(None, "选择tif数据", self.detectionInputTif.text(), "GeoTIFF (*.tif)")
        self.detectionInputTif.setText(str(input_tif_path))
        self.settings.setValue('detection_data_path', str(input_tif_path))

    def detection_land_path_clicked(self):
        input_land_path, _ = QFileDialog.getOpenFileName(None, "选择陆地面数据", self.detectionInputLand.text(), "shape file(*.shp)")
        self.detectionInputLand.setText(str(input_land_path))
        self.settings.setValue('detection_land_path', str(input_land_path))       

    def detection_data_op_clicked(self):
        save_path, _ = QFileDialog.getSaveFileName(None, "选择保存路径", self.detectionOutputShp.text(), "shape file(*.shp)")
        if len(save_path) > 4 and save_path[-4:] != ".shp":
            save_path += ".shp"
        self.detectionOutputShp.setText(save_path)
        self.settings.setValue('detection_save_path', save_path)

    def checkParamData(self, points_layer, no_data_value, geo_transform, RasterXSize, RasterYSize, idx):
        for i in range(RasterXSize):
            pixel_value = self.band_array[idx, i]

            #无效值不处理
            if no_data_value is not None and (pixel_value - no_data_value) <= np.finfo(np.float64).resolution:
                continue
            
            if self.tmp_band_array[idx, i] == 0 and pixel_value >= self.threshold:
                #根据周围值进行计算
                startX = i - self.search_radius_pixel
                endX = i + self.search_radius_pixel
                startY = idx - self.search_radius_pixel
                endY = idx + self.search_radius_pixel
                # if (startX < 0 and endX >= RasterXSize) or (startY < 0 and endY >= RasterYSize):
                #     continue
                
                if startY < 0:
                    startY = 0

                if endY > RasterYSize-1:
                    endY = RasterYSize-1

                if startX < 0:
                    startX = 0

                if endX > RasterXSize-1:
                    endX = RasterXSize-1

                values = []
                for m in range(startX, endX+1):
                    for n in range(startY, endY+1):
                        if m == startX or m == endX or n == startY or n == endY:
                            arround_value =  self.band_array[n, m]
                            if no_data_value is not None and (arround_value - no_data_value) <= np.finfo(np.float64).resolution:
                                continue

                            if arround_value > self.threshold:
                                continue

                            values.append(arround_value)

                average_value = self.default_water_value
                if len(values) != 0:
                    average_value = statistics.mean(values)

                x_pos = geo_transform[0] + i * geo_transform[1] + idx * geo_transform[2]
                y_pos = geo_transform[3] + i * geo_transform[4] + idx * geo_transform[5]
                r_point = QgsPoint(x_pos, y_pos)
                feature = QgsFeature()
                feature.setGeometry(r_point)
                feature.setAttributes([float(pixel_value), float(average_value), i, idx])
                points_layer.dataProvider().addFeature(feature)
            elif self.tmp_band_array[idx, i] != 0 and pixel_value < self.threshold:
                value_len = 1
                while True:
                    startX = i - value_len
                    endX = i + value_len
                    startY = idx - value_len
                    endY = idx + value_len
                    if (startX < 0 and endX >= RasterXSize) or (startY < 0 and endY >= RasterYSize):
                        break
                    
                    if startY < 0:
                        startY = 0

                    if endY > RasterYSize-1:
                        endY = RasterYSize-1

                    if startX < 0:
                        startX = 0

                    if endX > RasterXSize-1:
                        endX = RasterXSize-1

                    values = []
                    for m in range(startX, endX+1):
                        for n in range(startY, endY+1):
                            if m == startX or m == endX or n == startY or n == endY:
                                arround_value =  self.band_array[n, m]
                                if no_data_value is not None and (arround_value - no_data_value) <= np.finfo(np.float64).resolution:
                                    continue
                                if arround_value < self.threshold:
                                    continue

                                values.append(arround_value)

                    if len(values) == 0:
                        value_len =  value_len + 1
                        continue
                    
                    average_value = statistics.mean(values)
                    x_pos = geo_transform[0] + i * geo_transform[1] + idx * geo_transform[2]
                    y_pos = geo_transform[3] + i * geo_transform[4] + idx * geo_transform[5]
                    r_point = QgsPoint(x_pos, y_pos)
                    feature = QgsFeature()
                    feature.setGeometry(r_point)
                    feature.setAttributes([float(pixel_value), float(average_value), i, idx])
                    points_layer.dataProvider().addFeature(feature)
                    break
        return
                        
    def detection_process(self, detectionInputTif, tmp_tif_path, detectionOutputShp):
        raster_layer = QgsRasterLayer(detectionInputTif)
        raster_dataset = gdal.Open(detectionInputTif, gdal.GA_ReadOnly)
        geo_transform = raster_dataset.GetGeoTransform()
        raster_band = raster_dataset.GetRasterBand(1)
        no_data_value = raster_band.GetNoDataValue()
        self.band_array = raster_band.ReadAsArray()

        raster_ds = gdal.Open(tmp_tif_path)
        self.tmp_band_array = raster_ds.GetRasterBand(1).ReadAsArray()

        self.detection_progress_signal.emit(0, "")
        points_layer = QgsVectorLayer('Point?pt', 'pt','memory')
        points_layer.setProviderEncoding('UTF-8')
        points_layer.setCrs(raster_layer.crs())

        points_layer.dataProvider().addAttributes([QgsField('gc', QVariant.Double), QgsField('gcjz', QVariant.Double), QgsField('x', QVariant.Int), QgsField('y', QVariant.Int)])
        points_layer.updateFields()
        points_layer.startEditing()

        step_sum = raster_dataset.RasterYSize
        cur_step = 94.0 / step_sum
        cur_future_prog = 0
        current_prog = 0
        for i in range(raster_dataset.RasterYSize):
            # 提交任务到线程池中执行
            self.checkParamData(points_layer, no_data_value, geo_transform, raster_dataset.RasterXSize, raster_dataset.RasterYSize, i)

            #QgsMessageLog.logMessage(str(cur_step * cur_future_prog + 1), 'aaa', level=Qgis.MessageLevel.Info)
            cur_future_prog = cur_future_prog + 1
            prog = (int)(cur_step * cur_future_prog + 1)
            if prog > current_prog:
                current_prog = prog
                self.detection_progress_signal.emit(current_prog, "")
            
        points_layer.commitChanges()
        
        # if len(result_datas) > 0:
        #     cur_step = 10.0 / len(result_datas)
        #     cur_future_prog = 0
        #     for data in result_datas:
        #         feature = QgsFeature()
        #         feature.setGeometry(QgsGeometry.fromPointXY(data[0]))
        #         feature.setAttributes([float(data[1]), float(data[2]), data[3], data[4]])
        #         points_layer.dataProvider().addFeature(feature)
        #         cur_future_prog = cur_future_prog + 1
        #         self.detection_progress_signal.emit((int)(cur_step * cur_future_prog + 89), "")
        
        raster_dataset = None
        raster_ds = None
        os.remove(tmp_tif_path)   
        options = {}
        options['overwrite'] = True
        options['driverName'] = 'ESRI Shapefile'
        #options['driverName'] = 'GPKG'
        #options['layerName'] = 'my_out_table'
        QgsVectorLayerExporter.exportLayer(points_layer, detectionOutputShp, 'ogr', points_layer.crs(), False, options)
        self.detection_progress_signal.emit(100, "完成")        


    def reset_progress_bar(self):
        self.detectionProgressBar.setValue(0)
        self.correctProgressBar.setValue(0)

    def detection_proc(self, inputPath, detectionPath, outPath):
        if len(inputPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', 'tif数据不能为空')
            return
        
        if len(detectionPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '陆地面数据不能为空')
            return    
            
        if len(outPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '保存路径不能为空')
            return

        dataSource = ogr.Open(detectionPath)
        # vector_layer = QgsVectorLayer(detectionPath)
        if dataSource == None:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '陆地面数据无效')
            return
        layer = dataSource.GetLayer(0)

        raster_dataset = gdal.Open(inputPath, gdal.GA_ReadOnly)
        if raster_dataset is None:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '栅格数据数据无效')
            return

        #将矢量重投影到栅格坐标系统中
        driver = ogr.GetDriverByName("ESRI Shapefile")
        tmp_shp_path = os.path.splitext(outPath)[0] + '_tmp.shp'    
        #QgsMessageLog.logMessage(tmp_shp_path, 'aaa', level=Qgis.MessageLevel.Info)
        outDataSource = driver.CreateDataSource(tmp_shp_path)
        outLayer = outDataSource.CreateLayer("tmp", geom_type=layer.GetGeomType())
        transform = osr.CoordinateTransformation(layer.GetSpatialRef(), raster_dataset.GetSpatialRef())
        for feature in layer:
            geom = feature.GetGeometryRef()
            geom.Transform(transform)  # 重投影几何体
            out_feature = ogr.Feature(layer.GetLayerDefn())  # 创建新特征对象
            out_feature.SetGeometry(geom)  # 设置几何体到新特征对象中
            outLayer.CreateFeature(out_feature)  # 将新特征添加到输出图层中
            out_feature = None  # 释放内存（Python中没有直接的GC机制，但这里可以避免潜在的内存泄漏）
    
        dataSource = None  # 关闭矢量数据源（实际上在Python中不需要显式关闭，因为GC会处理）
        outDataSource.Destroy()

        tmp_tif_path = os.path.splitext(outPath)[0] + '_tmp.tif'    
        raster_layer = QgsRasterLayer(inputPath)
        raster_ex = raster_layer.extent()
        raster_str = 'gdal_rasterize -burn 1 -ot Byte -at -te {} {} {} {} -ot Byte -a_nodata 0 -ts {} {} {} {}'.format(raster_ex.xMinimum(), raster_ex.yMinimum(), \
                     raster_ex.xMaximum(), raster_ex.yMaximum(), raster_dataset.RasterXSize , raster_dataset.RasterYSize, tmp_shp_path, tmp_tif_path)
        subprocess.call(raster_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        base_name = os.path.splitext(tmp_shp_path)[0]
        os.remove(tmp_shp_path)
        os.remove(base_name + '.shx')
        os.remove(base_name + '.dbf')
        os.remove(base_name + '.prj')

        tmp_tif_ds = gdal.Open(tmp_tif_path, gdal.GA_Update)
        tmp_tif_ds.SetSpatialRef(raster_dataset.GetSpatialRef())
        tmp_tif_ds.FlushCache()
        tmp_tif_ds = None

        self.detection_process(inputPath, tmp_tif_path, outPath)
        # thread = Thread(target=self.detection_process, args=(inputPath, tmp_tif_path, detectionPath, outPath))
        # thread.start()
        return
            
    def detection_process_button_clicked(self):
        if len(self.detectionInputTif.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', 'tif数据不能为空')
            return
        
        if len(self.detectionInputLand.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '陆地面数据不能为空')
            return    
            
        if len(self.detectionOutputShp.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '保存路径不能为空')
            return

        dataSource = ogr.Open(self.detectionInputLand.text())
        # vector_layer = QgsVectorLayer(detectionPath)
        if dataSource == None:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '陆地面数据无效')
            return
        layer = dataSource.GetLayer(0)

        raster_dataset = gdal.Open(self.detectionInputTif.text(), gdal.GA_ReadOnly)
        if raster_dataset is None:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '栅格数据数据无效')
            return
        # target_srs_wkt = raster_dataset.exportToWkt()
        # target_srs = osr.SpatialReference()
        # target_srs.ImportFromWkt(target_srs_wkt)

        #将矢量重投影到栅格坐标系统中
        driver = ogr.GetDriverByName("ESRI Shapefile")
        tmp_shp_path = os.path.splitext(self.detectionOutputShp.text())[0] + '_tmp.shp'    
        #QgsMessageLog.logMessage(tmp_shp_path, 'aaa', level=Qgis.MessageLevel.Info)
        outDataSource = driver.CreateDataSource(tmp_shp_path)
        outLayer = outDataSource.CreateLayer("tmp", raster_dataset.GetSpatialRef(), geom_type=layer.GetGeomType())
        transform = osr.CoordinateTransformation(layer.GetSpatialRef(), raster_dataset.GetSpatialRef())
        for feature in layer:
            geom = feature.GetGeometryRef()
            geom.Transform(transform)  # 重投影几何体
            out_feature = ogr.Feature(layer.GetLayerDefn())  # 创建新特征对象
            out_feature.SetGeometry(geom)  # 设置几何体到新特征对象中
            outLayer.CreateFeature(out_feature)  # 将新特征添加到输出图层中
            out_feature = None  # 释放内存（Python中没有直接的GC机制，但这里可以避免潜在的内存泄漏）
    
        dataSource = None  # 关闭矢量数据源（实际上在Python中不需要显式关闭，因为GC会处理）
        outDataSource.Destroy()

        tmp_tif_path = os.path.splitext(self.detectionOutputShp.text())[0] + '_tmp.tif'    
        raster_layer = QgsRasterLayer(self.detectionInputTif.text())
        raster_ex = raster_layer.extent()
        raster_str = 'gdal_rasterize -burn 1 -ot Byte -at -te {} {} {} {} -ot Byte -a_nodata 0 -ts {} {} {} {}'.format(raster_ex.xMinimum(), raster_ex.yMinimum(), \
                     raster_ex.xMaximum(), raster_ex.yMaximum(), raster_dataset.RasterXSize , raster_dataset.RasterYSize, tmp_shp_path, tmp_tif_path)
        subprocess.call(raster_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        tmp_tif_ds = gdal.Open(tmp_tif_path, gdal.GA_Update)
        tmp_tif_ds.SetSpatialRef(raster_dataset.GetSpatialRef())
        tmp_tif_ds.FlushCache()
        tmp_tif_ds = None

        base_name = os.path.splitext(tmp_shp_path)[0]
        os.remove(tmp_shp_path)
        os.remove(base_name + '.shx')
        os.remove(base_name + '.dbf')
        os.remove(base_name + '.prj')

        #self.detection_process(self.detectionInputTif.text(),tmp_tif_path, self.detectionOutputShp.text())
        thread = Thread(target=self.detection_process, args=(self.detectionInputTif.text(),tmp_tif_path, self.detectionOutputShp.text()))
        thread.start()
        return
    
    def correct_data_path_clicked(self):
        input_tif_path, _ = QFileDialog.getOpenFileName(None, "选择tif数据", self.correctInputTif.text(), "GeoTIFF (*.tif)")
        self.correctInputTif.setText(str(input_tif_path))
        self.settings.setValue('correct_data_path', str(input_tif_path))

    def correct_path_clicked(self):
        input_shp_path, _ = QFileDialog.getOpenFileName(None, "选择水系数据", self.correctInputShp.text(), "shape file(*.shp)")
        self.correctInputShp.setText(str(input_shp_path))
        self.settings.setValue('correct_shp_path', str(input_shp_path))       

    def correct_data_op_clicked(self):
        save_path, _ = QFileDialog.getSaveFileName(None, "选择保存路径", self.correctOutputTif.text(), "GeoTIFF (*.tif)")
        if len(save_path) > 4 and save_path[-4:] != ".tif":
            save_path += ".tif"
        self.correctOutputTif.setText(save_path)
        self.settings.setValue('correct_save_path', save_path)

    def correct_proc(self, inputPath, affPath, outPath):
        if len(inputPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', 'tif数据不能为空')
            return
        
        if len(affPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后shp数据不能为空')
            return   
             
        if len(outPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后tif数据不能为空')
            return

        vector_layer = QgsVectorLayer(affPath)
        if vector_layer.isValid() == False or vector_layer.featureCount() == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后shp数据没有数据')
            else:
                print("没有需要校正的位置,校正完成")
                # self.correct_progress_signal.emit(100, "完成") 
            return
        
        self.correct_progress_signal.emit(0, "")
        shutil.copyfile(inputPath, outPath)
        correct_dataset = gdal.Open(outPath, gdal.GA_Update)
        correct_band = correct_dataset.GetRasterBand(1)
        step = 99.0 / vector_layer.featureCount()
        current_step = 0.0
        iter_features = vector_layer.getFeatures()
        for feature in iter_features:
            x = feature.attribute('x')
            y = feature.attribute('y')
            correct_value = feature.attribute('gcjz')
            correct_band.WriteArray(np.array([[correct_value]]), x, y)
            current_step = current_step + step
            self.correct_progress_signal.emit((int)(current_step), "")

        correct_dataset.FlushCache()
        correct_dataset = None    
        self.correct_progress_signal.emit(100, "完成")    
        return

    def correct_process_button_clicked(self):
        if len(self.correctInputTif.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', 'tif数据不能为空')
            return
        
        if len(self.correctInputShp.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后shp数据不能为空')
            return   
             
        if len(self.correctOutputTif.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后tif数据不能为空')
            return

        vector_layer = QgsVectorLayer(self.correctInputShp.text())
        if vector_layer.isValid() == False or vector_layer.featureCount() == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '校正后shp数据没有数据')  
            return
        
        self.correct_progress_signal.emit(0, "")
        shutil.copyfile(self.correctInputTif.text(), self.correctOutputTif.text())
        correct_dataset = gdal.Open(self.correctOutputTif.text(), gdal.GA_Update)
        correct_band = correct_dataset.GetRasterBand(1)
        step = 99.0 / vector_layer.featureCount()
        current_step = 0.0
        iter_features = vector_layer.getFeatures()
        for feature in iter_features:
            x = feature.attribute('x')
            y = feature.attribute('y')
            correct_value = feature.attribute('gcjz')
            correct_band.WriteArray(np.array([[correct_value]]), x, y)
            current_step = current_step + step
            self.correct_progress_signal.emit((int)(current_step), "")

        correct_dataset.FlushCache()
        correct_dataset = None    
        self.correct_progress_signal.emit(100, "完成")    
        return
        
    def on_close_button_clicked(self):
        self.close()
