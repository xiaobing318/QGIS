# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dataFormatConvertDialog
                                 A QGIS plugin
 dataFormatConvert
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-01-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by xing qiu
        email                : xing qiu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import glob
import shutil
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from PyQt5.QtCore import QThread, pyqtSignal, QVariant, QSettings
from os.path import split, splitext
from osgeo import ogr
from qgis.core import QgsMessageLog, QgsVectorLayer, QgsFeature, QgsWkbTypes, QgsFeatureSink, QgsField, QgsWkbTypes, QgsProviderRegistry, QgsVectorFileWriter, QgsProject, QgsWkbTypes, QgsRectangle, QgsCoordinateTransform,QgsVectorLayerExporter, Qgis
import concurrent.futures
import threading
from osgeo import gdal
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dataInDatabase_dialog_base.ui'))


class dataInDatabaseDialog(QtWidgets.QDialog, FORM_CLASS):
    progress_signal = pyqtSignal(int, str)

    def __init__(self, parent=None, showDlg=True):
        """Constructor."""
        super(dataInDatabaseDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.showDlg = showDlg
        #浏览数据目录
        self.inputPushButton.clicked.connect(self.on_data_dir_clicked)

        #浏览附属数据检测的数据
        self.ancillaryPushButton.clicked.connect(self.on_affiliation_button_clicked)

        #浏览处理结果目录
        self.outputPushButton.clicked.connect(self.on_data_op_clicked)
        
        #开始转换处理
        self.inDatabaseButton.clicked.connect(self.on_process_button_clicked)

        #关闭对话框
        self.closeButton.clicked.connect(self.on_close_button_clicked)

        self.settings = QSettings('XingqiuCompany', 'dataInDatabase')
        self.inputLineEdit.setText(self.settings.value('data_path', ''))
        self.ancillaryLineEdit.setText(self.settings.value('ancillary_path', ''))
        
        affiliation_layer = QgsVectorLayer(self.ancillaryLineEdit.text())
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

        self.outputLineEdit.setText(self.settings.value('op_path', ''))
        self.max_thread_num = 10

        dataType = self.settings.value('data_type', 0, type=int)
        if dataType == 0:
            self.radioInputShp.setChecked(True)
        else:
            self.radioInputGpkg.setChecked(True)

        outDataType = self.settings.value('out_data_type', 0, type=int)
        if outDataType == 0:
            self.radioOutputGpkg.setChecked(True)
        else:
            self.radioOutputGdb.setChecked(True)

        is_combine_database = self.settings.value('is_combine_database', 0, type=int)
        self.checkBox.setChecked(is_combine_database != 0)

        self.progress_signal.connect(self.connect_fun)

    def reset_progress_bar(self):
        self.progressBar.setValue(0)

    def connect_fun(self, prog, msg_data):
        if self.showDlg:
            self.progressBar.setValue(prog)
        else:
            print("当前进度:" + str(prog) + "%")

        if prog >= 100:
            if self.showDlg:
                QMessageBox.information(None, '提示', msg_data)
            else:
                print("运行完成！")

    def on_data_dir_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择数据目录", "")
        self.inputLineEdit.setText(str(folder_path))
        self.settings.setValue('data_path', str(folder_path))

    def on_affiliation_button_clicked(self):
        affiliation_filename_path, ok = QFileDialog.getOpenFileName(self,
                                "选择附属文件",
                               "",
                                "shape Files (*.shp)")
        if ok:
            self.ancillaryLineEdit.setText(str(affiliation_filename_path))
            self.settings.setValue('ancillary_path', str(affiliation_filename_path))

        affiliation_layer = QgsVectorLayer(affiliation_filename_path)
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

    def on_data_op_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择处理结果目录", "")
        self.outputLineEdit.setText(str(folder_path))
        self.settings.setValue('op_path', str(folder_path))

    def get_Gpkg_Layers(self, gpkg_path):
        layer_list = []
        driver = ogr.GetDriverByName('GPKG')
        gpkg_source = driver.Open(gpkg_path, 0)  # 0 表示只读模式
        if gpkg_source is None:
            return layer_list
        
        # 获取所有图层名称
        layers = gpkg_source.GetLayerCount()  # 获取图层数量
        layer_names = [gpkg_source.GetLayerByIndex(i).GetName() for i in range(layers)]
        for name in layer_names:
            uri = f'{gpkg_path}|layername={name}'
            layer = QgsVectorLayer(uri, name, 'ogr')
            if layer.isValid() and (layer.geometryType() == QgsWkbTypes.PointGeometry or layer.geometryType() == QgsWkbTypes.LineGeometry or layer.geometryType() == QgsWkbTypes.PolygonGeometry):
                layer_list.append(layer)
        return layer_list    

    def compute_data_by_affiliation(self, inputPath, inputDataType, affiliation_layer):
        vector_layers = []
        #layers_extent = QgsRectangle()

        if inputDataType == 0:
            filterName = "*.shp"
            vector_files = glob.glob(os.path.join(inputPath, filterName))
            if len(vector_files) == 0:
                return -1, []
            
            for vector_file in vector_files:
                vector_layer = QgsVectorLayer(vector_file)
                if vector_layer.isValid() == False:
                    continue
                if len(vector_layer.name()) == 0:
                    layer_name = splitext(split(vector_file)[1])[0]
                    vector_layer.setName(layer_name)       

                #layers_extent.combineExtentWith(vector_layer.extent())      
                vector_layers.append(vector_layer)
        else:
            layers = self.get_Gpkg_Layers(inputPath)
            for vector_layer in layers:
                if vector_layer.isValid() == False:
                    continue
                #layers_extent.combineExtentWith(vector_layer.extent())    
                vector_layers.append(vector_layer)  

        result_layers = {}
        for vector_layer in vector_layers:
            vector_iterator = vector_layer.getFeatures()
            
            data_tongji = {}
            last_feature = None
            select_fid = -1
            for vector_feature in vector_iterator:
                vector_geo = vector_feature.geometry()

                if last_feature != None:
                    last_feature_geo = last_feature.geometry()
                    if last_feature_geo.contains(vector_geo) == True:
                        last_fid = last_feature.id()
                        if last_fid not in data_tongji:
                            data_tongji[last_fid] = 1
                        else:
                            data_tongji[fid] = data_tongji[last_fid] + 1
                        if data_tongji[last_fid] >= vector_layer.featureCount()/2:
                           select_fid = last_fid
                           break
                        continue

                iterator = affiliation_layer.getFeatures()
                for feature in iterator:
                    feature_geo = feature.geometry()
                    if feature_geo.contains(vector_geo) == False:
                        continue
                    fid = feature.id()
                    if fid not in data_tongji:
                        data_tongji[fid] = 1
                    else:
                        data_tongji[fid] = data_tongji[fid] + 1
                    if data_tongji[fid] >= vector_layer.featureCount()/2:
                        select_fid = fid
                        iterator.close()
                        break
                    last_feature = feature
                    iterator.close()
                    break

                if select_fid != -1:
                    vector_iterator.close()
                    break

            vector_iterator.close()
            if select_fid == -1:
                continue

            if select_fid not in result_layers:
                result_layers[select_fid] = [vector_layer]
            else:
                result_layers[select_fid] = result_layers[select_fid] + [vector_layer]
  
        return result_layers
        
    
    def export_datas(self, attrib_name, dict_datas, dict_key, affiliation_layer, outDir, is_combine_database, outDataType):
        # attrib_name = 'f_dataname'
        affiliation_feature = affiliation_layer.getFeature(dict_key)
        feature_field_index = affiliation_layer.fields().indexOf(attrib_name)

        out_file_suffix = '.gpkg' if outDataType == 0 else '.gdb'
        if feature_field_index == -1:
            out_grid_name = str(dict_key)
        else:
            out_grid_name = affiliation_feature.attribute(attrib_name)

        result_layers = {}
        if is_combine_database:
            for data_layer in dict_datas[dict_key]:
                if data_layer.isValid() == False:
                    continue
                data_layer_name = data_layer.name()
                split_layer_names = data_layer_name.split('_')
                out_layer_name = split_layer_names[1]
                for i in range(2, len(split_layer_names)):
                    out_layer_name = out_layer_name + '_' + split_layer_names[i]
                if out_layer_name in result_layers:
                    result_layers[out_layer_name].append(data_layer)
                else:
                    result_layers[out_layer_name] = [data_layer]
        else:
            for data_layer in dict_datas[dict_key]:
                if data_layer.isValid() == False:
                    continue
                data_layer_name = data_layer.name()
                result_layers[data_layer_name] = [data_layer]            
        
        result_data_path = os.path.join(outDir, out_grid_name + out_file_suffix)
        return result_data_path, result_layers
        
    def process(self, inputPath, inputType, affPath, affField, outPath, is_combine_database, outType):
        if len(inputPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        
        if len(affPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '附属文件不能为空')
            return
        
        if len(outPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '处理结果目录不能为空')
            return
        
        affiliation_layer = QgsVectorLayer(affPath)
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"
        
        if self.showDlg:
            self.progressBar.setValue(1)
            QApplication.processEvents()
        else:
            print('开始入库')
        
        vector_dirs = os.listdir(inputPath)
        if len(vector_dirs) == 0:
            if self.showDlg:
                QMessageBox.information(None, '提示', '没有找到需要进行处理的文件夹')
            return
        
        thread = threading.Thread(target=self.in_db, args=(vector_dirs, is_combine_database, affiliation_layer, outPath , affField, inputType, outType))
        thread.start()

    def on_process_button_clicked(self):
        inputDataType = 0 if self.radioInputShp.isChecked() else 1
        outDataType = 0 if self.radioOutputGpkg.isChecked() else 1
        if len(self.inputLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        
        if len(self.ancillaryLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '附属文件不能为空')
            return
        
        if len(self.outputLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '处理结果目录不能为空')
            return
        
        affiliation_layer = QgsVectorLayer(self.ancillaryLineEdit.text())
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        self.settings.setValue('data_type', 0 if self.radioInputShp.isChecked() else 1)
        self.settings.setValue('out_data_type', outDataType)
        self.settings.setValue('is_combine_database', 1 if self.checkBox.isChecked() else 0)
        is_combine_database = self.checkBox.isChecked()

        self.progressBar.setValue(1)
        if self.showDlg:
            QApplication.processEvents()
        
        vector_dirs = os.listdir(self.inputLineEdit.text())
        if len(vector_dirs) == 0:
            if self.showDlg:
                QMessageBox.information(None, '提示', '没有找到需要进行处理的文件夹')
            return
        
        # thread = threading.Thread(target=self.in_db, args=(vector_dirs, is_combine_database, affiliation_layer, self.outputLineEdit.text() , self.comboBox.currentText(), inputDataType, outDataType))
        # thread.start()
        self.in_db(vector_dirs, is_combine_database, affiliation_layer, self.outputLineEdit.text() , self.comboBox.currentText(), inputDataType, outDataType)
        

    def in_db(self, vector_dirs, is_combine_database, affiliation_layer, out_dir, current_combo_text, inputDataType, outDataType):
        prog = 30.0 / len(vector_dirs)
        idx = 0
        dictFeatureIds = {}
        #并发通过内buff去掉不在图幅边缘内的矢量id
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行
            data_task = { executor.submit(self.compute_data_by_affiliation, os.path.join(self.inputLineEdit.text(), vector_dirs[n]), inputDataType, affiliation_layer): n for n in range(len(vector_dirs)) }
            # 等待所有任务完成
            for future_data in concurrent.futures.as_completed(data_task):
                feature_layers = future_data.result()
                for feature_id in feature_layers:
                    if feature_id not in dictFeatureIds:
                        dictFeatureIds[feature_id] = feature_layers[feature_id]
                    else:
                        dictFeatureIds[feature_id] = dictFeatureIds[feature_id] + feature_layers[feature_id]
                idx = idx + 1
                self.progress_signal.emit((int)(prog * idx + 1), "")

            if len(dictFeatureIds) == 0:
                if self.showDlg:
                    self.progress_signal.emit(100, "没有附属数据范围内数据,处理结束")
                return
        
            #并发计算图层间关系
            step = 20.0 / len(dictFeatureIds)
            curprog = 0

            result_vector_datas = {}
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行
                future_to_task = { executor.submit(self.export_datas, current_combo_text, dictFeatureIds, dict_key, affiliation_layer, out_dir, is_combine_database, outDataType): dict_key for dict_key in dictFeatureIds }
            
                # 等待所有任务完成
                for future in concurrent.futures.as_completed(future_to_task):
                    out_path, vector_layers = future.result()
                    result_vector_datas[out_path] = vector_layers
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 31), "")

                step = 45.0 / len(result_vector_datas)
                curprog = 0
                out_driver_name = 'GPKG' if outDataType == 0 else 'FileGDB'
                                
                options = {'update': True, 'driverName': out_driver_name}
                if outDataType == 1:
                    options.update({
                        'FID': 'OBJECTID',
                        'GEOMETRY_NULLABLE': 'NO',
                        'DIM': 'XY',
                        'GEOMETRY_NAME': 'SHAPE'
                    })
                for result_vector_path in result_vector_datas:
                    if os.path.exists(result_vector_path):
                        if outDataType == 0:
                            os.remove(result_vector_path)
                        else:
                            shutil.rmtree(result_vector_path)
                    ogr.GetDriverByName(out_driver_name).CreateDataSource(result_vector_path)
                    for out_layer_name in result_vector_datas[result_vector_path]:
                        out_vector_layers = result_vector_datas[result_vector_path][out_layer_name]
                        if len(out_vector_layers) == 0:
                            continue
                        wkbType = QgsWkbTypes.displayString(out_vector_layers[0].wkbType())
                        out_write_layer = QgsVectorLayer(wkbType, out_layer_name, "memory")
                        out_write_layer.startEditing()
                        for index in range(len(out_vector_layers)):
                            if outDataType == 0:
                                current_fields = out_write_layer.fields()
                                vector_fields = out_vector_layers[index].fields()
                                for vector_field in vector_fields:
                                    if current_fields.indexOf(vector_field.name().lower()) == -1 and vector_field.name().lower() != "fid" and vector_field.name() != "OBJECTID":
                                        if vector_field.type() != QVariant.LongLong:
                                            out_write_layer.addAttribute(vector_field)
                                        else:
                                            out_write_layer.addAttribute(QgsField(vector_field.name(), QVariant.Int))
                                out_write_layer.updateFields()
                                features = out_vector_layers[index].getFeatures()
                                current_fields = out_write_layer.fields()
                                add_feature = QgsFeature()
                                add_feature.setFields(current_fields)
                                for feature in features:
                                    add_feature.setGeometry(feature.geometry())
                                    for vector_field in vector_fields:
                                        field_index = current_fields.indexOf(vector_field.name())
                                        if field_index == -1:
                                            field_index = current_fields.indexOf(vector_field.name().lower())
                                        if field_index != -1:
                                            try:
                                                data_value = feature.attribute(vector_field.name())
                                                add_feature.setAttribute(field_index, data_value)
                                            except ValueError:
                                                pass
                                    out_write_layer.addFeature(add_feature)
                                features.close()
                                add_feature = None
                            else:
                                current_fields = out_write_layer.fields()
                                vector_fields = out_vector_layers[index].fields()
                                for vector_field in vector_fields:
                                    if current_fields.indexOf(vector_field.name()) == -1 and vector_field.name() != "OBJECTID" and vector_field.name() != "fid":
                                        #QgsMessageLog.logMessage(str(vector_field.type()) + str(vector_field.typeName()) + str(vector_field.subType()), 'aaa', level=Qgis.MessageLevel.Info)
                                        if vector_field.type() != QVariant.LongLong:
                                            out_write_layer.addAttribute(vector_field)
                                        else:
                                            out_write_layer.addAttribute(QgsField(vector_field.name(), QVariant.Int))
                                out_write_layer.updateFields()
                                features = out_vector_layers[index].getFeatures()
                                current_fields = out_write_layer.fields()
                                add_feature = QgsFeature()
                                add_feature.setFields(current_fields)
                                for feature in features:
                                    add_feature.setGeometry(feature.geometry())
                                    for vector_field in vector_fields:
                                        field_index = current_fields.indexOf(vector_field.name())
                                        if field_index != -1:
                                            try:
                                                data_value = feature.attribute(vector_field.name())
                                                add_feature.setAttribute(field_index, data_value)
                                            except ValueError:
                                                pass
                                    out_write_layer.addFeature(add_feature)
                                features.close()
                                add_feature = None 
                        if out_write_layer != None:
                            out_write_layer.commitChanges()
                            out_write_layer.flushBuffer()
                            options['layerName'] = out_layer_name
                            QgsVectorLayerExporter.exportLayer(out_write_layer, result_vector_path, "ogr", out_vector_layers[0].crs(), False, options)
                            out_write_layer = None

                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 51), "")
                for result_vector_path in result_vector_datas:
                    for out_layer_name in result_vector_datas[result_vector_path]:
                        for index in range(len(out_vector_layers)):
                            out_vector_layers[index] = None

                self.progress_signal.emit(100, "完成")

    def on_close_button_clicked(self):
        self.close()
