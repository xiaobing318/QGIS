# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dataFormatConvertDialog
                                 A QGIS plugin
 dataFormatConvert
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-01-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by xing qiu
        email                : xing qiu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import glob
import shutil
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from PyQt5.QtCore import QThread, pyqtSignal, QVariant, QSettings
from os.path import split, splitext
from osgeo import ogr
from qgis.core import (
    QgsMessageLog, QgsVectorLayer, QgsFeature, QgsFeatureSink, QgsField, 
    QgsProviderRegistry, QgsVectorFileWriter, QgsProject, QgsWkbTypes, 
    QgsRectangle, QgsCoordinateTransform,QgsVectorLayerExporter, Qgis,
    QgsGeometry, QgsDistanceArea, QgsUnitTypes)
import concurrent.futures
import threading

# ① 头部 imports —— 在原有 import 列表下方多加一行
from osgeo import gdal                         # ←★新增               

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dataInDatabase_dialog_base.ui'))


class dataInDatabaseDialog(QtWidgets.QDialog, FORM_CLASS):
    progress_signal = pyqtSignal(int, str)

    def __init__(self, parent=None, showDlg=True):
        """Constructor."""
        super(dataInDatabaseDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.showDlg = showDlg
        #浏览数据目录
        self.inputPushButton.clicked.connect(self.on_data_dir_clicked)

        #浏览附属数据检测的数据
        self.ancillaryPushButton.clicked.connect(self.on_affiliation_button_clicked)

        #浏览处理结果目录
        self.outputPushButton.clicked.connect(self.on_data_op_clicked)
        
        #开始转换处理
        self.inDatabaseButton.clicked.connect(self.on_process_button_clicked)

        #关闭对话框
        self.closeButton.clicked.connect(self.on_close_button_clicked)

        self.settings = QSettings('XingqiuCompany', 'dataInDatabase')
        self.inputLineEdit.setText(self.settings.value('data_path', ''))
        self.ancillaryLineEdit.setText(self.settings.value('ancillary_path', ''))
        
        affiliation_layer = QgsVectorLayer(self.ancillaryLineEdit.text())
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

        self.outputLineEdit.setText(self.settings.value('op_path', ''))
        self.max_thread_num = 10

        dataType = self.settings.value('data_type', 0, type=int)
        if dataType == 0:
            self.radioInputShp.setChecked(True)
        else:
            self.radioInputGpkg.setChecked(True)

        outDataType = self.settings.value('out_data_type', 0, type=int)
        if outDataType == 0:
            self.radioOutputGpkg.setChecked(True)
        else:
            self.radioOutputGdb.setChecked(True)

        is_combine_database = self.settings.value('is_combine_database', 0, type=int)
        self.checkBox.setChecked(is_combine_database != 0)

        self.progress_signal.connect(self.connect_fun)

    def reset_progress_bar(self):
        self.progressBar.setValue(0)

    def connect_fun(self, prog, msg_data):
        if self.showDlg:
            self.progressBar.setValue(prog)
        else:
            print("当前进度:" + str(prog) + "%")

        if prog >= 100:
            if self.showDlg:
                QMessageBox.information(None, '提示', msg_data)
            else:
                print("运行完成！")

    def on_data_dir_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择数据目录", "")
        self.inputLineEdit.setText(str(folder_path))
        self.settings.setValue('data_path', str(folder_path))

    def on_affiliation_button_clicked(self):
        affiliation_filename_path, ok = QFileDialog.getOpenFileName(self,
                                "选择附属文件",
                               "",
                                "shape Files (*.shp)")
        if ok:
            self.ancillaryLineEdit.setText(str(affiliation_filename_path))
            self.settings.setValue('ancillary_path', str(affiliation_filename_path))

        affiliation_layer = QgsVectorLayer(affiliation_filename_path)
        self.comboBox.clear()
        if affiliation_layer.isValid():
            for field in affiliation_layer.fields():
                if field.type() != QVariant.String:
                    continue
                self.comboBox.addItem(field.name())
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

    def on_data_op_clicked(self):
        folder_path = QFileDialog.getExistingDirectory(None, "选择处理结果目录", "")
        self.outputLineEdit.setText(str(folder_path))
        self.settings.setValue('op_path', str(folder_path))

    def get_Gpkg_Layers(self, gpkg_path):
        layer_list = []
        driver = ogr.GetDriverByName('GPKG')
        gpkg_source = driver.Open(gpkg_path, 0)  # 0 表示只读模式
        if gpkg_source is None:
            return layer_list
        
        # 获取所有图层名称
        layers = gpkg_source.GetLayerCount()  # 获取图层数量
        layer_names = [gpkg_source.GetLayerByIndex(i).GetName() for i in range(layers)]
        for name in layer_names:
            uri = f'{gpkg_path}|layername={name}'
            layer = QgsVectorLayer(uri, name, 'ogr')
            if layer.isValid() and (layer.geometryType() == QgsWkbTypes.PointGeometry or layer.geometryType() == QgsWkbTypes.LineGeometry or layer.geometryType() == QgsWkbTypes.PolygonGeometry):
                layer_list.append(layer)
        return layer_list    

    def robust_contains(self,
                        candidate: QgsGeometry,
                        polygon: QgsGeometry,
                        tol_ratio: float = 0.9,
                        ellipsoid: str = 'WGS84') -> bool:
        """
        用双缓冲重叠面积比补判。

        :param candidate: 点/线/面候选几何
        :param polygon:   面要素（附加面）
        :param tol_ratio: 重叠面积 / min(缓冲后面积, 面要素面积) 的阈值
        :param ellipsoid: 面积测算用椭球
        """
        # 1. 以 QGIS 自带的 DistanceArea 计算 geodesic area
        dist = QgsDistanceArea()
        dist.setEllipsoid(ellipsoid)

        # 2. 构造类型相关缓冲（°），再转椭球面积比较
        if candidate.wkbType() == QgsWkbTypes.Point:
            buf = candidate.buffer(0.00005, 8)  # 约 5~6 m（需要根据纬度调节）
        elif QgsWkbTypes.geometryType(candidate.wkbType()) == QgsWkbTypes.LineGeometry:
            buf = candidate.buffer(0.0001, 8)   # 约 10 m
        else:                                   # Polygon
            buf = candidate  # 面不做缓冲

        inter = buf.intersection(polygon)
        if inter.isEmpty():
            return False

        overlap = dist.measureArea(inter)
        min_area = min(dist.measureArea(buf), dist.measureArea(polygon))

        return (overlap / min_area) >= tol_ratio

    # 总体目的：通过附加矢量面图层计算得到要素ID集合
    # 参数一：输入数据路径（这里指的就是分幅数据目录在文件系统中的位置）；参数二：输入数据类型（如果为0则表示输入数据类型是shapefile，如果为1则表示输入数据类型时Geopackage）
    # 参数三：附加矢量面图层
    def compute_data_by_affiliation(self, inputPath, inputDataType, affiliation_layer):
    # 创建一个用来保存矢量图层的数组
        vector_layers = []
        #layers_extent = QgsRectangle()

        # 如果输入数据类型等于0则表示输入数据类型是shapefile
        if inputDataType == 0:
            # 创建一个用来过滤数据类型的变量
            filterName = "*.shp"
            # 将分幅数据目录中的后缀为.shp的数据过滤得到全部的shapefile绝对路径（在分幅数据目录中存在很多不同的文件即二进制流）
            vector_files = glob.glob(os.path.join(inputPath, filterName))
            # 如果分幅数据目录中后缀为.shp的文件个数为0，则直接返回-1和空的数组
            if len(vector_files) == 0:
                return -1, []
            # 循环处理分幅数据目录中的每一个shapefile矢量图层
            for vector_file in vector_files:
                # 使用qgis中的接口将当前shapefile矢量图层读取到内存中等待处理
                vector_layer = QgsVectorLayer(vector_file)
                # 如果当前shapefile矢量图层不是有效的则继续处理下一个shapefile矢量图层
                if vector_layer.isValid() == False:
                    continue
                # 如果shapefile矢量图层的名称长度为0（没有给当前shapefile矢量图层赋予名称，自动添加名称）
                if len(vector_layer.name()) == 0:
                    layer_name = splitext(split(vector_file)[1])[0]
                    vector_layer.setName(layer_name)       

                #layers_extent.combineExtentWith(vector_layer.extent())      
                # 将经过判断、预处理的shapefile矢量图层添加到临时变量中供后续使用
                vector_layers.append(vector_layer)
        # 如果输入数据类型等于为1则表示输入数据类型时Geopackage
        else:
            # 通过当前类中读取GeoPackage的接口将其中的shapefile矢量图层
            layers = self.get_Gpkg_Layers(inputPath)
            # 循环处理GeoPackage中的每一个shapefile矢量图层
            for vector_layer in layers:
                # 如果当前shapefile矢量图层不是有效的，跳过处理当前shapefile矢量图层
                if vector_layer.isValid() == False:
                    continue
                #layers_extent.combineExtentWith(vector_layer.extent())    
                # 将经过判断、预处理的shapefile矢量图层添加到临时变量中供后续使用
                vector_layers.append(vector_layer)  

        # 创建一个directory变量
        result_layers = {}
        # 循环处理经过预处理的shapefile矢量图层
        for vector_layer in vector_layers:
            # 获取得到当前shapefile矢量图层的所有要素并且将其当做迭代器进行使用
            vector_iterator = vector_layer.getFeatures()
            # 创建一个directory变量用来统计
            data_tongji = {}
            last_feature = None
            select_fid = -1
            # 循环处理当前图层中的所有矢量要素（需要对边界情况进行处理，边界情况是处理矢量图层中的矢量要素数量）
            for vector_feature in vector_iterator:
                # 获取得到当前矢量要素的几何信息
                vector_geo = vector_feature.geometry()
                # 如果当前处理的矢量要素不是最后一个那么执行代码块中的内容（这里指的并不是辅助图层中最后的面要素，而是辅助图层中的当前要素，只不过当前要素针对当前待处理的矢量图层没有处理完）
                if last_feature != None:
                    # 获取最后一个处理矢量要素的几何信息 
                    last_feature_geo = last_feature.geometry()
                    # 如果附加矢量要素包含当前处理矢量要素，则进行一些单独的处理
                    """
                    概述：这里的判断两个矢量要素的集合位置关系的目的就是为了判断当前处理矢量要素是否在附加矢量面要素中，但是对于面要素来说，
                    存在一些边界情况是contains方法无法判断的，因此需要对附加矢量面要素进行一些特殊处理。例如：如果当前处理矢量要素在附加矢
                    量面要素的边界上，那么contains方法返回False，但是实际上当前处理矢量要素是包含在附加矢量面要素中的。
                    
                    算法：双缓冲区重叠面积比例算法
                    1. 获取当前处理矢量要素和附加矢量面要素的几何信息。
                    2. 根据当前矢量要素的几何类型(点、线、面)，设计缓冲区，并且计算缓冲区之后的面积，注意这里不需要对面进行缓冲。
                    3. 计算附加矢量面要素的几何信息的面积，注意这里不需要对面进行缓冲。
                    4. 判断当前处理矢量要素的缓冲区和附加矢量面要素的几何信息是否相交，如果相交则计算重叠面积。
                    5. 如果重叠面积同当前处理矢量要素的缓冲区面积和附加矢量面要素的几何信息的面积中的最小值之间的比例大于等于0.9，
                    则认为当前处理矢量要素包含在附加矢量面要素中。
                    """
                    #if last_feature_geo.contains(vector_geo) == True:
                    if self.robust_contains(vector_geo, last_feature_geo):
                        last_fid = last_feature.id()
                        if last_fid not in data_tongji:
                            data_tongji[last_fid] = 1
                        else:
                            data_tongji[fid] = data_tongji[last_fid] + 1
                        if data_tongji[last_fid] >= vector_layer.featureCount()/2:
                           select_fid = last_fid
                           break
                        continue
                # 获取得到附加矢量面图层中的所有矢量要素并且将其当成迭代器进行使用
                iterator = affiliation_layer.getFeatures()
                # 循环处理附加矢量面图层中的所有矢量面要素
                for feature in iterator:
                    # 获取得到当前附加矢量面图层中当前面要素的几何信息
                    feature_geo = feature.geometry()
                    # 如果当前矢量面要素几何位置上不包含当前处理矢量要素，则跳过处理下一个附加矢量面图层的矢量面要素
                    # 总体目的：从几何位置上判断附加面要素是否和当前处理矢量要素产生包含关系
                    """
                    概述：这里的判断两个矢量要素的集合位置关系的目的就是为了判断当前处理矢量要素是否在附加矢量面要素中，但是对于面要素来说，
                    存在一些边界情况是contains方法无法判断的，因此需要对附加矢量面要素进行一些特殊处理。例如：如果当前处理矢量要素在附加矢
                    量面要素的边界上，那么contains方法返回False，但是实际上当前处理矢量要素是包含在附加矢量面要素中的。
                    
                    算法：双缓冲区重叠面积比例算法
                    1. 获取当前处理矢量要素和附加矢量面要素的几何信息。
                    2. 根据当前矢量要素的几何类型(点、线、面)，设计缓冲区，并且计算缓冲区之后的面积，注意这里不需要对面进行缓冲。
                    3. 计算附加矢量面要素的几何信息的面积，注意这里不需要对面进行缓冲。
                    4. 判断当前处理矢量要素的缓冲区和附加矢量面要素的几何信息是否相交，如果相交则计算重叠面积。
                    5. 如果重叠面积同当前处理矢量要素的缓冲区面积和附加矢量面要素的几何信息的面积中的最小值之间的比例大于等于0.9，
                    则认为当前处理矢量要素包含在附加矢量面要素中。
                    """
                    #if feature_geo.contains(vector_geo) == False:
                    if not self.robust_contains(vector_geo, feature_geo):
                        continue
                    # 获取得到当前附加矢量面要素的ID属性
                    fid = feature.id()
                    # 如果得到的当前附加矢量面要素的ID属性不在统计字典中，则建立附加矢量面要素的ID属性、1的字典
                    if fid not in data_tongji:
                        data_tongji[fid] = 1
                    # 如果得到的当前附加矢量面要素的ID属性在统计字典中，则将当前附加矢量面要素包含的处理矢量要素加一
                    else:
                        data_tongji[fid] = data_tongji[fid] + 1
                    # 如果统计字典中当前面要素包含的处理要素数量比当前处理图层要素数量二分之一大于等于的话则关闭迭代器（假设处理矢量图层中只有1,2,3个要素的时候？）
                    if data_tongji[fid] >= vector_layer.featureCount()/2:
                        select_fid = fid
                        iterator.close()
                        break
                    # 将当前要素赋值给临时变量
                    last_feature = feature
                    # 关闭迭代器跳出循环
                    iterator.close()
                    break
                if select_fid != -1:
                    vector_iterator.close()
                    break
            # 关闭处理图层中的矢量要素迭代器
            vector_iterator.close()
            if select_fid == -1:
                continue
            # TODO:（可能的整体效果就是将归属到不同附加矢量面要素的处理要素挑选出来并且形成一个字典）
            if select_fid not in result_layers:
                result_layers[select_fid] = [vector_layer]
            else:
                result_layers[select_fid] = result_layers[select_fid] + [vector_layer]
  
        return result_layers
        
    
    def export_datas(self, attrib_name, dict_datas, dict_key, affiliation_layer, outDir, is_combine_database, outDataType):
        # attrib_name = 'f_dataname'
        affiliation_feature = affiliation_layer.getFeature(dict_key)
        feature_field_index = affiliation_layer.fields().indexOf(attrib_name)

        out_file_suffix = '.gpkg' if outDataType == 0 else '.gdb'
        if feature_field_index == -1:
            out_grid_name = str(dict_key)
        else:
            out_grid_name = affiliation_feature.attribute(attrib_name)

        result_layers = {}
        if is_combine_database:
            for data_layer in dict_datas[dict_key]:
                if data_layer.isValid() == False:
                    continue
                data_layer_name = data_layer.name()
                split_layer_names = data_layer_name.split('_')
                out_layer_name = split_layer_names[1]
                for i in range(2, len(split_layer_names)):
                    out_layer_name = out_layer_name + '_' + split_layer_names[i]
                if out_layer_name in result_layers:
                    result_layers[out_layer_name].append(data_layer)
                else:
                    result_layers[out_layer_name] = [data_layer]
        else:
            for data_layer in dict_datas[dict_key]:
                if data_layer.isValid() == False:
                    continue
                data_layer_name = data_layer.name()
                result_layers[data_layer_name] = [data_layer]            
        
        result_data_path = os.path.join(outDir, out_grid_name + out_file_suffix)
        return result_data_path, result_layers
        
    def process(self, inputPath, inputType, affPath, affField, outPath, is_combine_database, outType):
        # 通过简单验证输入数据路径长度来判断输入数据路径是否存在
        if len(inputPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        # 通过简单验证输入数据路径长度来判断输入数据路径是否存在
        if len(affPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '附属文件不能为空')
            return
        # 通过简单验证输入数据路径长度来判断输入数据路径是否存在
        if len(outPath) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '处理结果目录不能为空')
            return
        # 通过QGIS函数将附加图层读取到内存当中
        affiliation_layer = QgsVectorLayer(affPath)
        # 如果附加图层数据不是有效的或者附加图层数据的几何类型不是面几何类型，直接返回并且给出提示信息
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"
        # 如果对话框有效，设置交互相关内容
        if self.showDlg:
            self.progressBar.setValue(1)
            QApplication.processEvents()
        else:
            print('开始入库')
        # 获取输入数据路径中的子文件夹，并将其保存在子文件夹列表中
        vector_dirs = os.listdir(inputPath)
        # 如果获取到的子文件夹为0，那么说明给到的输入数据目录中没有对应的子文件夹（一个子文件夹代表一个分幅数据）
        if len(vector_dirs) == 0:
            # 如果对话框有效，则显示提示信息
            if self.showDlg:
                QMessageBox.information(None, '提示', '没有找到需要进行处理的文件夹')
            # 如果对话框无效，直接退出
            return
        # 线程准备工作：在当前进程中启用一个线程用来数据入库的实际操作，第一个参数是线程调用的函数，第二个参数是传入指定函数的参数
        thread = threading.Thread(target=self.in_db, args=(vector_dirs, is_combine_database, affiliation_layer, outPath , affField, inputType, outType))
        # 启用线程
        thread.start()

    def on_process_button_clicked(self):
        inputDataType = 0 if self.radioInputShp.isChecked() else 1
        outDataType = 0 if self.radioOutputGpkg.isChecked() else 1
        if len(self.inputLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '数据目录不能为空')
            return
        
        if len(self.ancillaryLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '附属文件不能为空')
            return
        
        if len(self.outputLineEdit.text()) == 0:
            if self.showDlg:
                QMessageBox.warning(self, '警告', '处理结果目录不能为空')
            return
        
        affiliation_layer = QgsVectorLayer(self.ancillaryLineEdit.text())
        if affiliation_layer.isValid() == False or affiliation_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "affiliation file is not polygon"

        self.settings.setValue('data_type', 0 if self.radioInputShp.isChecked() else 1)
        self.settings.setValue('out_data_type', outDataType)
        self.settings.setValue('is_combine_database', 1 if self.checkBox.isChecked() else 0)
        is_combine_database = self.checkBox.isChecked()

        self.progressBar.setValue(1)
        if self.showDlg:
            QApplication.processEvents()
        
        vector_dirs = os.listdir(self.inputLineEdit.text())
        if len(vector_dirs) == 0:
            if self.showDlg:
                QMessageBox.information(None, '提示', '没有找到需要进行处理的文件夹')
            return
        
        # thread = threading.Thread(target=self.in_db, args=(vector_dirs, is_combine_database, affiliation_layer, self.outputLineEdit.text() , self.comboBox.currentText(), inputDataType, outDataType))
        # thread.start()
        self.in_db(vector_dirs, is_combine_database, affiliation_layer, self.outputLineEdit.text() , self.comboBox.currentText(), inputDataType, outDataType)
        
    # 参数一：子文件夹列表；参数二：是否在GPKG/GDB中将数据合并；参数三：附加图层路径；参数四：输出路径；
    # 参数五：附加字段名称；参数六：输入数据类型（如果为0则表示输入数据类型是shapefile，如果为1则表示输入数据类型时Geopackage）
    # 参数七：如果为0则表示输出数据类型为GeoPackage,如果为1则表示输出数据类型为GDB
    def in_db(self, vector_dirs, is_combine_database, affiliation_layer, out_dir, current_combo_text, inputDataType, outDataType):
        # 30 / 分幅数据数量
        prog = 30.0 / len(vector_dirs)
        # 将索引值设置为0
        idx = 0
        # 创建一个directory用来保存矢量要素的ID字段值
        dictFeatureIds = {}
        # 1、并发处理提高处理速度；2、整体效果是为了去掉当前附加图层中某个面外的要素ID
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
            # 提交任务到线程池中执行，将每一个分幅数据进行循环处理
            data_task = { executor.submit(self.compute_data_by_affiliation, os.path.join(self.inputLineEdit.text(), vector_dirs[n]), inputDataType, affiliation_layer): n for n in range(len(vector_dirs)) }
            # 等待所有任务完成，每一个任务就是对一个分幅数据的处理，因此这里循环获取得到每个分幅数据处理之后满足要求的图层数据
            for future_data in concurrent.futures.as_completed(data_task):
                # 获取当前任务（分幅数据）处理之后的结果（满足要求的矢量图层）
                feature_layers = future_data.result()
                # 循环处理当前字典中的数组数据（满足要求的要素ID）
                for feature_id in feature_layers:
                    # 如果当前满足要求的要素ID不在对应的字典中（TODO：这里需要对调用函数的返回数据结构熟悉）
                    if feature_id not in dictFeatureIds:
                        dictFeatureIds[feature_id] = feature_layers[feature_id]
                    else:
                        dictFeatureIds[feature_id] = dictFeatureIds[feature_id] + feature_layers[feature_id]
                idx = idx + 1
                self.progress_signal.emit((int)(prog * idx + 1), "")
            # 如果变量中的字典长度为0则给出提示信息
            if len(dictFeatureIds) == 0:
                if self.showDlg:
                    self.progress_signal.emit(100, "没有附属数据范围内数据,处理结束")
                return
        
            # 并发计算图层间关系
            # 设置进度条相关内容
            step = 20.0 / len(dictFeatureIds)
            curprog = 0
            # 创建一个临时变量用来保存处理得到的矢量数据结果
            result_vector_datas = {}
            # 创建多线程实体并且给出别名
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_thread_num) as executor:
                # 提交任务到线程池中执行（调用导入数据函数，传入所需要的参数）
                future_to_task = { executor.submit(self.export_datas, current_combo_text, dictFeatureIds, dict_key, affiliation_layer, out_dir, is_combine_database, outDataType): dict_key for dict_key in dictFeatureIds }
            
                # 等待所有任务完成，并且更新进度条
                for future in concurrent.futures.as_completed(future_to_task):
                    out_path, vector_layers = future.result()
                    result_vector_datas[out_path] = vector_layers
                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 31), "")
                # 进度条相关内容
                step = 45.0 / len(result_vector_datas)
                curprog = 0
                
                # 通过输出数据类型赋值变量的字符串值（如果输出数据类型为0，则将变量赋值为GPKG;如果输出数据类型为1，则将变量赋值为OpenFileGDB）
                # 这里需要知道矢量数据驱动的原因是后续对数据的处理需要根据不同的数据格式来调用不同的矢量数据驱动
                # ② 选择驱动 —— 把 out_driver_name 的判断留成三元式，但改成 FileGDB
                out_driver_name = 'GPKG' if outDataType == 0 else 'FileGDB'   # ←★修改
                
                
                # ③ layer / dataset 创建选项 —— 扩充  options  字典，仅在 FileGDB 时追加
                options = {'update': True, 'driverName': out_driver_name}     # 原有代码
                if outDataType == 1:                                          # ←★新增块
                    options.update({                                          #   仅 FileGDB 才加
                        'FID': 'OBJECTID',            # 明确 OID 字段，ArcGIS/FME 识别更稳
                        'GEOMETRY_NULLABLE': 'NO',    # 禁止空几何，避免“线变点”               :contentReference[oaicite:0]{index=0}
                        'DIM': 'XY',                  # 强制 2D 输出，相当于 ogr2ogr -dim 2    :contentReference[oaicite:1]{index=1}
                        'GEOMETRY_NAME': 'SHAPE'      # 保持 Esri 默认列名（可选）
                    })
                
                
                # 循环处理结果矢量数据
                for result_vector_path in result_vector_datas:
                    # 如果结果矢量数据路径是存在的话，根据不同的数据类型对结果数据进行处理
                    if os.path.exists(result_vector_path):
                        if outDataType == 0:
                            os.remove(result_vector_path)
                        else:
                            shutil.rmtree(result_vector_path)
                    # 通过ogr来选择具体的矢量数据驱动并且根据输出路径创建数据源
                    ogr.GetDriverByName(out_driver_name).CreateDataSource(result_vector_path)
                    # 循环处理每个筛选数据中的矢量图层
                    for out_layer_name in result_vector_datas[result_vector_path]:
                        # 获取得到当前多个矢量图层
                        out_vector_layers = result_vector_datas[result_vector_path][out_layer_name]
                        # 如果当前多个矢量图层数量为空，则直接处理下一个筛选后的矢量图层集合
                        if len(out_vector_layers) == 0:
                            continue
                        # 获取得到矢量图层集合中的第一个矢量图层的几何类型
                        wkbType = QgsWkbTypes.displayString(out_vector_layers[0].wkbType())
                        # 创建一个临时保存在内存中的图层
                        out_write_layer = QgsVectorLayer(wkbType, out_layer_name, "memory")
                        # 对临时保存在内存中的图层进行编辑操作
                        out_write_layer.startEditing()
                        # 循环处理矢量图层集合中的每一个图层
                        for index in range(len(out_vector_layers)):
                            # 如果输出数据类型是GPKG（如果输出数据类型为0，则将变量赋值为GPKG;如果输出数据类型为1，则将变量赋值为OpenFileGDB）
                            if outDataType == 0:
                                # 获取得到输出图层的字段信息
                                current_fields = out_write_layer.fields()
                                # 获取当前筛选图层集合中的当前图层中的字段信息
                                vector_fields = out_vector_layers[index].fields()
                                # 循环处理筛选图层中的所有字段信息
                                for vector_field in vector_fields:
                                    # 排除名称为fid和OBJECTID的字段
                                    if current_fields.indexOf(vector_field.name().lower()) == -1 and vector_field.name().lower() != "fid" and vector_field.name() != "OBJECTID":
                                        if vector_field.type() != QVariant.LongLong:
                                            out_write_layer.addAttribute(vector_field)
                                        else:
                                            out_write_layer.addAttribute(QgsField(vector_field.name(), QVariant.Int))
                                # 对输出图层进行更新
                                out_write_layer.updateFields()
                                # 获取得到当前筛选图层中的所有矢量要素
                                features = out_vector_layers[index].getFeatures()
                                # 获取得到输出图层的字段信息
                                current_fields = out_write_layer.fields()
                                add_feature = QgsFeature()
                                add_feature.setFields(current_fields)
                                # 对所有要素进行处理
                                for feature in features:
                                    add_feature.setGeometry(feature.geometry())
                                    for vector_field in vector_fields:
                                        field_index = current_fields.indexOf(vector_field.name())
                                        if field_index == -1:
                                            field_index = current_fields.indexOf(vector_field.name().lower())
                                        if field_index != -1:
                                            try:
                                                data_value = feature.attribute(vector_field.name())
                                                add_feature.setAttribute(field_index, data_value)
                                            except ValueError:
                                                pass
                                    out_write_layer.addFeature(add_feature)
                                features.close()
                                add_feature = None
                            else:
                                current_fields = out_write_layer.fields()
                                vector_fields = out_vector_layers[index].fields()
                                for vector_field in vector_fields:
                                    if current_fields.indexOf(vector_field.name()) == -1 and vector_field.name() != "OBJECTID" and vector_field.name() != "fid":
                                        #QgsMessageLog.logMessage(str(vector_field.type()) + str(vector_field.typeName()) + str(vector_field.subType()), 'aaa', level=Qgis.MessageLevel.Info)
                                        if vector_field.type() != QVariant.LongLong:
                                            out_write_layer.addAttribute(vector_field)
                                        else:
                                            out_write_layer.addAttribute(QgsField(vector_field.name(), QVariant.Int))
                                out_write_layer.updateFields()
                                features = out_vector_layers[index].getFeatures()
                                current_fields = out_write_layer.fields()
                                add_feature = QgsFeature()
                                add_feature.setFields(current_fields)
                                for feature in features:
                                    add_feature.setGeometry(feature.geometry())
                                    for vector_field in vector_fields:
                                        field_index = current_fields.indexOf(vector_field.name())
                                        if field_index != -1:
                                            try:
                                                data_value = feature.attribute(vector_field.name())
                                                add_feature.setAttribute(field_index, data_value)
                                            except ValueError:
                                                pass
                                    out_write_layer.addFeature(add_feature)
                                features.close()
                                add_feature = None 
                        if out_write_layer != None:
                            out_write_layer.commitChanges()
                            out_write_layer.flushBuffer()
                            options['layerName'] = out_layer_name
                            QgsVectorLayerExporter.exportLayer(out_write_layer, result_vector_path, "ogr", out_vector_layers[0].crs(), False, options)
                            out_write_layer = None

                    curprog = curprog + 1
                    self.progress_signal.emit((int)(step * curprog + 51), "")
                for result_vector_path in result_vector_datas:
                    for out_layer_name in result_vector_datas[result_vector_path]:
                        for index in range(len(out_vector_layers)):
                            out_vector_layers[index] = None

                self.progress_signal.emit(100, "完成")

    def on_close_button_clicked(self):
        self.close()